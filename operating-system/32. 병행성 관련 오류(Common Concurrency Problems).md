# 32. 병행성 관련 오류 (Common Concurrency Problems)

병행성 관련 오류들을 다뤄보도록 한다. 대부분 초기 연구들은 **교착 상태(deadlock)** 에 초점이 맞춰 있었으나, 최근들어 교착 상태가 아닌 **다른 종류의 병행성 버그들(비 교착 상태 버그)** 을 많이 다루고 있다.

병행성 버그들을 어떻게 처리하는지를 알아보도록 한다.

---

## 32.1 오류의 종류 (What Types Of Bugs Exist?)

Lu와 같은 연구 내용에서는 병행성 오류에 어떤 것들이 있는지 확인하고자 대표적인 오픈소스 프로그램 4개에 집중하였다.

![img1](https://user-images.githubusercontent.com/35681772/59991757-92d7a900-9683-11e9-9eec-250134927399.png)

위와 같이 연구 결과 대부분의 오류는 교착 상태와 무관한 **'비 교착 상태'** 의 오류임을 확인하였다.

따라서 위 연구 내용을 바탕으로 비 교착 상태의 오류와 교착 상태의 오류에 대해 알아보도록 한다.

---

## 32.2 비 교착 상태 오류 (Non-Deadlock Bugs)

비 교착 상태 오류의 대표적인 두 종류의 오류는 다음과 같다.

  - 원자성 위반(atomicity violation) 오류
  
  - 순서 위반(order violation) 오류

---

### 원자성 위반 오류 (Atomicity-Violation Bugs)

![img2](https://user-images.githubusercontent.com/35681772/59991762-979c5d00-9683-11e9-9067-11cb1a813dfc.png)

위 그림은 MySQL에서 발견한 원자성 위반 오류를 보여주고 있다.

첫 번째 쓰레드 T1은 그 값이 NULL인지 검사하고, 값을 출력한다. 두 번째 쓰레드 T2는 값을 NULL로 설정한다.

쓰레드 T1이 검사를 완료한 후 fputs를 호출하기 전에 인터럽트가 발생하는 경우 쓰레드 T2가 그 사이에 실행될 수 있다. 이 때, 쓰레드 T2는 값을 NULL로 설정하기 때문에 그 후의 T1에서의 참조는 NULL pointer exception이 나게 된다. 따라서 프로그램은 크래시된다.

연구 자료에서 기술한 원자성 위반에 대한 정의는 다음과 같다.
> "다수의 메모리 참조 연산들 간에 있어 예상했던 직렬성(serializability)이 보장되지 않았다. 즉, 코드의 일부에 원자성이 요구되었으나, 실행 시에 그 원자성이 위반되었다."

따라서 이는 _**락** 을 추가하여 어느 쓰레드건 간에 proc_info 필드에 접근 시, proc_info_lock 이라는 락 변수를 획득하도록 하여_ 해결할 수 있다.

![img3](https://user-images.githubusercontent.com/35681772/59991766-9cf9a780-9683-11e9-8def-12cedb1fbc91.png)

---

### 순서 위반 오류 (Order-Violation Bugs)

또 다른 비 교착 상태 오류의 예로 **순서 위반** 오류가 있다.

![img4](https://user-images.githubusercontent.com/35681772/59991768-a1be5b80-9683-11e9-9c9a-00a3b159ee9e.png)

위의 코드에서 쓰레드 T2의 코드는 mThread 변수가 이미 초기화가 되어 NULL이 아닌 것을 가정하고 짜여져 있다. 하지만 쓰레드 T1이 먼저 실행되지 않아 초기화 되지 않는다면 역시나 NULL pointer exception이 된다.

연구 자료에서 기술한 순서 위반의 정의는 다음과 같다.
> "두 개의 메모리 참조 간의 순서가 바뀌었다. 즉, A가 항상 B보다 먼저 실행되어야 하지만, 실행 중에 그 순서가 지켜지지 않았다."

이러한 순서의 오류를 수정하는 데엔 앞서 다뤘듯 **컨디션 변수** 를 사용한다. 따라서 컨디션 변수를 사용하여 위의 순서 위반 오류를 해결하면 아래와 같다.

![img5](https://user-images.githubusercontent.com/35681772/59991776-aa169680-9683-11e9-9d0f-b867a8742d6f.png)

위 코드에서는 mtLock이라는 락, 그 락에 대한 컨디션 변수 mt_cond, 상태 변수 mtInit을 추가하였다.

init() 이 실행되면 mtInit을 1로 설정하여 초기화가 실행되었음을 설정해주고, signal을 보내 init이 되지 않아 자고 있던 쓰레드들을 깨우는 방식이다.

그래서 쓰레드 T2가 먼저 실행되더라도 wait에 걸려 sleep 상태에 들어가 있다가, init()이 실행 된 이후에 다시 깨어나는 식으로 순서를 강제하는 것이다.

물론 위에서 다뤄본 락과 컨디션 변수들의 예제는 세마포어를 사용하여도 해결이 된다.

---

### 비 교착 상태 오류 : 정리 (Non-Deadlock Bugs: Summary)

비 교착 상태 오류의 대부분은 원자성 또는 순서 위반에 대한 오류였다. 따라서 이런 패턴에 유의하여 설계하는 습관을 갖는것이 중요하다 할 수 있겠다.

---

## 32.3 교착 상태 오류 (Deadlock Bugs)

교착 상태는 아래와 같은 상황에서 발생한다. 

![img6](https://user-images.githubusercontent.com/35681772/59991788-b13da480-9683-11e9-897f-40d7c5d451c9.png)

락 L1을 갖고 있는 쓰레드 T1이 또 다른 락 L2를 기다리는 상황에서, 락 L2를 갖고 있는 쓰레드 T2가 락 L1을 기다리는 경우 **"교착 상태(deadlock)"** 이 발생하게 된다.

예를 들어 쓰레드 T1이 먼저 실행되어 L1을 획득한 직후 context switch가 일어나 쓰레드 T2가 실행되고 L2를 획득한 다음, L1을 획득하려 시도하지만 sleep에 들어가게 된다. 그 뒤 쓰레드 T1이 실행되면 마찬가지로 L2를 획득하려 시도하지만 sleep에 들어가게 되며 deadlock이 발생하게 된다.

각 쓰레드가 상대방이 소유하고 있는 락을 대기하고 있기 때문에 deadlock이 발생하게 된다.

![img7](https://user-images.githubusercontent.com/35681772/59991794-b7338580-9683-11e9-89e2-59491e26a007.png)

이렇게 락의 획득을 놓고 쓰레드 간 교착 상태가 발생하는 이유는 위와 같이 **"싸이클(cycle)"** 이 발생하기 때문이다. 싸이클의 존재는 교착 상태의 발생 가능성이 있음을 나타낸다.

---

### 교착 상태는 왜 발생하는가 (Why Do Deadlocks Occur?)

교착 상태가 발생하는 이유는 다음과 같다.

#### _"코드가 많아지면서 **구성 요소 간에 복잡한 의존성이 발생** 하기 때문"_ 이다.

OS의 경우 virtual memory system이 디스크 블럭을 가져오기 위해 file system을 접근하고, file system은 디스크 블럭을 메모리에 탑재하기 위해 메모리 페이지를 확보해야하고, 그러려면 virtual memory system에 접근해야 한다. 이렇게 순환식 의존성이 교착 상태를 야기하는 것이다.
  
#### _"**캡슐화(encapsulation)**"의 성질 때문_ 이다.

캡슐화 즉, 모듈화가 개발을 쉽게하는 데 도움을 주기 때문에 상세한 구현 내용을 감추게 된다. 하지만 전혀 문제가 없어 보이는 인터페이스에서도 교착 상태가 나타나기도 한다.

![img11](https://user-images.githubusercontent.com/35681772/59991800-bef32a00-9683-11e9-920e-512c59e2fc97.png)

예를 들어 자바의 위 메소드같은 경우 멀티 쓰레드에 안전해야 하므로 내부적으로는 v1에 더해지는 벡터뿐 아니라 인자로 전달되는 v2에 대한 락도 같이 획득해야 한다.

다른 쓰레드가 `v2.AddAll(v1);` 을 호출하면 교착 상태의 발생 가능성이 있다.

---

### 교착 상태 발생 조건

교착 상태의 발생 조건은 다음 네가지가 있다.

  - **상호 배제(Mutual Exclusion)** 의 존재 : 쓰레드가 자신이 필요로 하는 자원에 대한 독자적인 제어권을 주장한다(ex. 쓰레드가 락을 획득함).

  - **점유 및 대기(Hold-and-wait)** 의 존재 : 쓰레드가 자신에게 할당된 자원(ex. 이미 획득한 락)을 점유한 채로 다른 자원(ex. 획득하고자 하는 락)을 대기한다.

  - **비선점(No preemption)** 형 구조 : 자원(락)을 점유하고 있는 쓰레드로부터 자원을 강제적으로 빼앗을 수 없다.

  - **순환 대기 (Circular wait)** 상태 존재 : 각 쓰레드는 다음 쓰레드가 요청한 하나 또는 그 이상의 자원(락)을 갖고 있는 쓰레드들의 순환 고리가 있다.

이 네 조건이 모두 만족되지 않는다면 교착 상태는 발생하지 않는다. 따라서 위 각 조건들을 예방하거나 회피하는 방법들을 알아보자.

---

### 교착 상태의 예방


#### 순환 대기 (Circular wait)

Circular wait이 절대 발생하지 않도록 락 코드를 작성하는 것이 가장 실용적인 deadlock 예방 기법이다.

예를 들어, L1과 L2라는 두개의 락만 존재한다면 L1을 무조건 L2 획득 전에 획득하도록 하는 경우 순환은 발생하지 않게 된다. 그러면 deadlock 또한 발생하지 않게 된다.

복잡한 시스템에서는 락의 갯수가 많기 때문에 전체 락의 요청 순서를 정의하는 것이 어려울 수 있다. 이런 경우 _부분 순서(partial ordering)_ 를 제공하는 것이 락 획득 구조를 만드는 데 유용하다.

예를들어 Linux의 memory mapping 코드에서는 `i_mmap_mutex` 전에 `i_mutex` 를 획득해야 한다 와 같은 **부분 순서** 가 존재한다.

이렇게 락의 순서를 정의하기 위해서는 "코드와 다양한 루틴 간의 상하 호출 관계"를 잘 이해해야 한다.

<br>

#### 점유 및 대기 (Hold-and-Wait)

점유 및 대기의 문제는 _원자적으로 모든 락을 한번에 획득하도록_ 하면 예방할 수 있다.

![img12](https://user-images.githubusercontent.com/35681772/59991803-c61a3800-9683-11e9-852f-cd076c565abb.png)

위 코드에서는 먼저 prevention 락을 획득하도록 하여 다음 락을 획득하는 과정에서의 context switch 문제가 발생하는 것을 방지하고, 교착 상태의 발생 가능성을 차단한다.

이 방법은 '필요한 락들을 정확히 파악해야 하고, 그 락들을 미리 획득해야 한다'는 문제점이 있다. 락이 실제 필요할 때 요청하는 것이 아니라 미리 모든 락을 한번에 획득하기 때문에 '병행성이 저하'되는 문제도 있다.

<br>

#### 비선점 (No Preemption)

락을 해제하기 전 까지는 락을 보유하고 있는 것으로 처리되기 때문에 _여러 락을 획득하는 것에는 문제의 여지가 있다._

이미 락을 보유한 채 다른 락을 대기하면 그 때문에 sleep에 들어가는 쓰레드의 숫자들이 훨씬 많이 증가하여 병행성이 저하되기 때문이다.

따라서 `trylock()` 을 이용하면 교착 상태 가능성이 없고 획득 순서에 영향을 받지 않는 락 획득 방법을 만들 수 있다.

`trylock()` 루틴은 '획득 가능하다면' 락을 획득하고 그게 아니라면 락이 점유된 상태이니 락을 획득하기 원하면 나중에 다시 시도하라는 것을 알리는 -1 값을 리턴한다.

![img14](https://user-images.githubusercontent.com/35681772/59991810-ce727300-9683-11e9-850a-4f2033783ebe.png)

하지만 이 방법에는 **무한 반복(livelock)** 이 발생할 여지가 있다. 이를 방지하기 위해선 반복문에 지연 시간을 무작위로 조절하는 등의 대처가 필요하다.

`trylock()` 방식은 **캡슐화** 의 문제점을 갖는다. 사용하려는 락이 루틴 깊숙한 곳에 존재하는 경우 처음으로 다시 돌아가는 루틴을 구현하기 어렵다. 또한 실행 과정에서 자원을 획득한 것이 있다면 그 또한 반납해야 한다. 따라서 오버헤드가 클 수 있다는 것이다.


<br>

#### 상호 배제 (Mutual Exclusion)

마지막으로 상호 배제 자체를 아예 없애는 방법이다. Herlihy는 **wait-free 자료 구조** 를 고안했다. 명시적 락이 필요 없는 강력한 하드웨어 명령어를 사용하는 개념이다.

![img15](https://user-images.githubusercontent.com/35681772/59991826-d500ea80-9683-11e9-99fd-2c08c5d2fd09.png)

위 그림에서 `CompareAndSwap()` 이 원자적으로 실행됨이 보장되어 아래 `AtomicIncrement()` 에서 이를 가져다 사용하고 있다. 이렇게 되면 락을 사용할 필요가 없고, deadlock이 발생할 수도 없다. 단, 무한반복은 여전히 발생 가능성이 있다.

<br>

![img16](https://user-images.githubusercontent.com/35681772/59991828-da5e3500-9683-11e9-9db8-2c1d15825271.png)

위 그림처럼 리스트에 삽입하는 예시에서는 여러 쓰레드에 의해 '동시에' 호출되면 경쟁 조건(race condition)이 발생하게 된다. 이를 전통적인 '락'을 사용하여 처리하는 방법과 Compare-And-Swap을 사용하여 대기 없이 insert를 처리하는 방법을 보이고 있다.

Compare-And-Swap을 사용한 insert 과정에서 한 쓰레드가 삽입 도중 다른 쓰레드가 삽입을 완료한 경우 while에 의해 재시도가 일어나게 된다.

<br>

#### 스케줄링으로 교착 상태 회피하기 (Deadlock Avoidance via Scheduling)

교착 상태를 예방하는 것 보다 회피하는 것이 더 유용할 때가 있다. 이를 위해선 실행 중인 여러 쓰레드가 어떤 락을 획득하게 될 것인지에 대해 파악하고 있어야 하며, 그것을 바탕으로 쓰레드들을 스케줄링 하여 교착 상태가 발생하지 않도록 하는 것이다.

![img19](https://user-images.githubusercontent.com/35681772/59991834-e0541600-9683-11e9-9445-8adc78fd393a.png)

위 표는 각 쓰레드 T1, T2, T3, T4에 대한 락 L1, L2의 필요여부를 나타낸 것이다. 먼저 위의 경우 스케줄러가 T1과 T2를 같은 CPU내에 배치시킨다면, T1과 T2가 동시에 실행만 하지 않는다면 교착 상태가 절대로 발생하지 않게 된다.

마찬가지로 아래처럼 T1, T2, T3가 하나의 CPU에서 실행되어도 교착 상태가 발생하지 않지만 이렇게 구현할 시 **병행성이 떨어지고 성능이 하락하는 문제점을 갖게 된다.**

또한 이렇게 어떤 쓰레드가 어떤 락을 획득할 지를 알 수 있는것이 매우 제한적이므로, _임베디드 시스템_ 과 같은 곳에서 이런 방식을 사용하게 된다.

<br>

#### 발견 및 복구 (Detect and Recover)

마지막 전략은 교착 상태 발생을 허용하되, _교착 상태를 발견하면 **'복구'**_ 하는 방법이다.
이런 방식은 데이터베이스 시스템들에서 교착 상태를 발견하고 회복하는 기술을 사용하곤 한다. 

교착 상태의 발견은 주기적으로 '자원 할당 그래프'를 그려 싸이클이 생겼는지를 검사하게 된다. 싸이클이 발생하는 경우(교착 상태인 경우) 시스템을 재부팅하는 식이다.

---

## 32.4 요약

병행 프로그램에서 발생할 수 있는 오류의 종류들을 다뤄봤다. 

**비교착 상태 오류**로 _원자성 위반_, _순서 위반_ 오류를 다뤄봤다.

또한 **교착 상태 오류**가 발생하지 않기 위해 이를 방지하거나 회피하는 방법을 다뤘다.

마지막으로 **'락'은 원천적으로 문제점을 수반하기 때문에 제한적으로 사용하는 것이 권장된다.**

---


