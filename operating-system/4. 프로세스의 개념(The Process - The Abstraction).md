# 4\. 프로세스의 개념(The Abstraction : The Process)

**프로세스(Process)** : 실행 중인 프로그램. 프로그램 자체는 생명이 없는 존재다. 명령어와 정적 데이터의 묶음일 뿐임.

**시분할(Time-Sharing)**

- 사용자는 하나 이상의 프로그램을 동시에 실행시키는것에 익숙한데 이 '동시에 실행된다'는 생각은 **운영체제가 CPU를 가상화(virtualizing)** 하여 환상(illusion)을 주기 때문에 우리가 그렇게 느끼는 것이다.
- 사실은 하나의 프로세스를 실행하고 중단하고 다른 프로세스를 실행하는 작업을 반복하여, 실제 하나 또는 소수의 CPU로 여러 개의 가상 CPU가 존재하는 듯한 환상을 만들어 낸다.
- **시분할(Time-Sharing)** 이라 부르는 기법이 이를 가능하게 하는데, 원하는 수 만큼의 프로세스를 동시에 실행할 수 있게 한다. Time-Sharing은 CPU를 공유하기 때문에, 각 프로세스의 성능은 낮아진다.

**운영체제에서 CPU 가상화를 구현하기 위해 필요한 것**

- 메커니즘(Mechanism) : 필요한 기능을 구현하는 방법이나 규칙(ex. Context Switch)
- 정책(Policy) : 운영체제 내에서 어떤 결정을 내리기 위한 알고리즘(ex. 스케줄링 정책(Scheduling Policy)).

---

## 4.1 프로세스의 개념

프로세스(Process)

- 실행 중인 프로그램

프로세스의 실행에 필요한 하드웨어(component of machine state that comprises a process)

- **메모리(Memory)** : 명령어나 프로세스가 읽고 쓰는 데이터 등이 저장된다. _프로세스가 접근할 수 있는 메모리를 주소공간(Address Space)_ 이라 부름.
- **레지스터(Register)** : 많은 명령어들이 레지스터를 직접 읽거나 갱신한다. 프로세스의 하드웨어 상태를 구성하는 레지스터 중 _프로그램 카운터(Program Counter, PC aka. Instruction Pointer, IP)는 프로그램의 어느 명령어가 실행 중인지를 알려준다._ 그 외 스택을 관리할 때 사용하는 레지스터인 _스택 포인터(Stack Pointer), 프레임 포인터(Frame Pointer)_ 등이 있다.
- **영구 저장장치(persistent storage devices)**

---

## 4.2 프로세스 API

운영체제가 반드시 API로 제공해야 하는 기본 기능들로는 다음과 같다. 이런 API를 제공해야 프로세스들을 manage 할 수 있다.

- _생성(Create)_ : 프로세스를 생성할 수 있는 방법을 제공해야 한다.
- _제거(Destroy)_ : 프로세스를 강제로 제거할 수 있는 인터페이스를 제공해야 한다.
- _대기(Wait)_ : 어떤 프로세스의 실행 중지를 기다릴 필요가 있기 때문에 대기 인터페이스가 필요하다.
- _각종 제어(Miscellaneous Control)_ : 프로세스를 일시정지하거나 다시 시작하는 기능들을 제공해야 한다.
- _상태(Status)_ : 프로세스 상태 정보를 얻어내는 인터페이스도 필요로 한다. 얼마 동안 실행되었는지, 현재 어떤 상태에 있는지 등의 정보를 제공해줘야 한다.

---

## 4.3 프로세스 생성 : 프로그램이 프로세스로 변형되는 과정

운영체제가 프로그램을 준비하고 실행시켜 프로세스로 만드는 과정은 아래와 같다.

![img1](https://user-images.githubusercontent.com/35681772/59987651-cd3a4980-9675-11e9-8686-ef6a15de3a05.png)

1) *코드와 정적 데이터를 메모리에 탑재* : 프로그램은 디스크 등의 저장공간에서 실행 파일(exe)형식으로 존재한다. 이것들을 운영체제가 디스크에서 해당 바이트를 읽어 메모리의 어딘가에 저장(탑재)한다.
2) *스택과 힙을 생성하고 초기화* : 프로세스가 사용할 스택과 힙 공간을 초기화 한다. main()함수에서 인자로 argc, argv 벡터를 사용하여 스택을 초기화함. 
3) *I/O(입출력) 셋업 초기화* : 프로세스가 사용할 파일 디스크립터(File Descriptor)등을 셋팅한다.
4) *프로그램 실행* : main() 루틴으로 들어가게 됨으로써 운영체제는 CPU를 새로 생성된 프로세스에게 할당하고 프로그램이 시작된다.

---

## 4.4 프로세스 상태(State)

![img2](https://user-images.githubusercontent.com/35681772/59987863-dcb99280-9675-11e9-97fd-915fa6d09724.png)

  - 실행(Running) : 프로세스가 명령어를 실행하고 있는 상태
  - 준비(Ready) : 프로세스는 실행할 준비가 되어있지만, 운영체제가 다른 프로세스를 실행하고 있는 등의 이유로 실행 준비가 된 채 Ready Queue에서 CPU의 할당을 기다리는 상태.
  - 대기(Blocked) : 프로세스가 다른 이벤트를 기다리는 동안 프로세스의 수행을 중단시키는 연산. 흔히 프로세스가 I/O 요청을 하였을 때 I/O가 완료될 때 까지 대기상태가 되고, 다른 프로세스가 실행 상태로 될 수 있다.

그 외, 초기(initial) 상태(프로세스가 생성되는 때의 상태), 최종(final, zombie)상태(프로세스가 종료되었지만 메모리에 남아있는 상태) 등이 있음.

![img3](https://user-images.githubusercontent.com/35681772/59988010-e7742780-9675-11e9-9bfe-577cc2f49337.png)
  
  - 위와같이 프로세스간 CPU가 전환되며 사용된다.
  - 운영체제는 스케줄러를 통해 어떤 프로세스를 먼저 실행시킬지 결정하게 된다.

---

## 4.5 자료 구조
운영체제도 일종의 프로그램이기 때문에 프로세스 상태를 파악하기 위해 준비 상태의 프로세스들을 관리하는 *프로세스 리스트(Process List)*, 프로세스가 중단되었을 때 해당 프로세스의 레지스터 값들을 저장하고 *필요할 때 이 레지스터 값을 복원하여 프로세스 실행을 재개(문맥 교환, Context Switch)* 할 때 사용되는 *레지스터 문맥(Register Context)* 등이 존재한다.

---
## 4.6 요약
프로세스는 실행 중인 프로그램 이기 때문에, 운영체제가 프로세스를 구현하는 데에 필요한 기법들이나 구현한 프로세스를 스케줄링하는 정책 등을 중점적으로 CPU 가상화에 대해 초점을 맞춰 알아나간다.

---