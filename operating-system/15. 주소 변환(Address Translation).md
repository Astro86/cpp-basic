# 15. 주소 변환(Address Translation) : 가상 주소에서 물리 주소로의 변환

*제한적 직접 실행(LDE)* 이라는 기법은 프로그램이 하드웨어(CPU)에서 직접 실행되는데, 프로세스가 System Call을 호출하거나 Timer-Interrupt가 발생할 때와 같이 특정 순간에 운영체제가 개입하여 문제가 발생하지 않도록 직접 제어하여 Efficiency와 Control을 모두 추구한다.

메모리 가상화에서도 마찬가지로 가상화를 제공하는 동시에 효율성(Efficiency)과 제어(Control) 그리고 유연성(Flexibility)을 추구하고자 다양한 방법을 사용한다. 특히 이 두가지를 모두 개선하고자 Hardware의 도움이 필요하다(부팅할 때 셋업이 되어있어야 하기 때문. 부팅시 메인보드 내의 Bios에 부팅 코드들이 들어있는데 Bios → OS 순으로 탑재됨).

효율성을 높히기 위해 그리고 프로그램이 자기자신 이외의 메모리에 접근하지 못하도록 제어를 하기위해 운영체제는 **하드웨어의 도움** 을 받는다.

**주소 변환(Address Translation, Virtual Address to Physical Address)이라는 기술은 하드웨어가 명령어 반입, 탑재, 저장 등의 가상 주소를 정보가 실제 존재하는 물리 주소로 변환할 수 있도록 한다.** 이걸 OS가 하면 너무 느려지게 된다.

Hardware가 setup 해 놓은 Virtual Address to/from Physical Address 이것은 메모리 Table을 참조하여 수행되는데 이 table을 OS가 관리한다.

이러한 작업들의 목표는 *"프로그램이 자신의 전용 메모리를 소유하고 그 안에 자신의 코드와 데이터가 있다는 illusion을 주기위함"* 이다.

---

## 15.1 가정

사용자 주소 공간은 물리 메모리에 연속적으로 배치되어 있고, 각 주소 공간의 크기는 같다고 가정하고 주소 변환의 구현에 대해 단계별로 알아본다.

---

## 15.2 사례

![img4](https://user-images.githubusercontent.com/35681772/59989745-720b5580-967b-11e9-8f64-576226588673.png)

이 코드는 우측과 같이 어셈블리어로 변환되는데, 위 코드의 결과는 아래처럼 프로세스 주소 공간에 코드와 데이터가 배치된다.
  
![img3](https://user-images.githubusercontent.com/35681772/59989753-7a639080-967b-11e9-9bba-3b95af5b7a5a.png)

명령어는 코드 영역에, 변수 x의 값은 스택 영역에 위치한다.

이 어셈블리 명령어는 다음과 같은 절차로 동작하게 된다.
  1. 주소 128의 명령어를 반입 → 이 명령어 실행(주소 15KB에서 탑재)
  2. 주소 132의 명령어를 반입 → 이 명령어 실행(메모리 참조 없음)
  3. 주소 135의 명령어를 반입 → 이 명령어 실행(15KB에 저장)

프로세스 주소 공간이 실제로는 다른 물리 주소에 배치되어 있을 때, 주소 0번지부터 시작하는 가상 주소 공간의 illusion을 주려면 어떤 방법을 사용하여야 할까?

---

## 15.3 동적(하드웨어-기반) 재배치(Dynamic(Hardware-based) Relocation) : 가상화의 한 형태

![img5](https://user-images.githubusercontent.com/35681772/59989771-82233500-967b-11e9-9b0c-fe6f65227081.png)

**'베이스'와 '바운드'(base and bound, aka. 동적 재배치(Dynamic Relocation)** : '베이스' 라는 레지스터와 '바운드' 라는 레지스터는 하나의 쌍을 이루어 우리가 원하는 위치에 주소 공간을 배치할 수 있게 한다. 

프로그램 시작 시, 운영체제가 프로그램이 탑재 될 물리 메모리 위치를 결정하고 '베이스' 레지스터를 그 주소로 지정한다. 위 그림에서 '베이스' 레지스터의 값은 물리 주소 32KB에 해당됨. 즉, **'베이스' 레지스터 : 프로그램이 탑재 될 물리 메모리의 위치 주소**

![img6](https://user-images.githubusercontent.com/35681772/59989778-894a4300-967b-11e9-9733-727558acf547.png)

그 후, **프로세스에 의해 생성되는 모든 주소가 위와 같은 방법으로 프로세서에 의해 변환된다. 프로세스가 가상 주소(virtual address)를 생성하면, 하드웨어는 '베이스' 레지스터의 내용을 이 주소에 더하여 물리 주소를 생성한다.**

![img7](https://user-images.githubusercontent.com/35681772/59989786-8fd8ba80-967b-11e9-85ca-6bb831879d5d.png)

위 명령어를 예로 들면, 프로그램 카운터 PC는 128로 설정되고, 하드웨어가 먼저 이 PC 값을 '베이스' 레지스터의 값 32KB(32768)에 더해 32896의 물리 주소를 얻는다. 그 후 하드웨어는 해당 물리 주소에서 명령어를 가지고 온다. 그리고 프로세서는 명령어의 실행을 시작한다. 그 다음 프로세스는 가상 주소 15KB의 값을 탑재하라는 명령어를 내리고, 이 주소를 프로세서가 받아 다시 '베이스' 레지스터(32KB)를 더하고 물리 주소 47KB에서 원하는 내용을 탑재한다. 이것이 **동적 재배치(Dynamic Relocation)** 이다.

**'바운드' 레지스터** : 프로세스가 생성한 모든 주소가 합법적이고 프로세스의 '범위'에 있다는 것을 확인하고자, 프로세스는 먼저 메모리 참조가 적절한가를 확인하기 위해 가상 주소가 '바운드' 안에 있는지 확인한다. 하드웨어는 가상 주소를 베이스 레지스터에 더하기 전 먼저 바운드 레지스터와 비교하여 범위내에 있는지를 확인한다. 이와 같이 **'바운드' 레지스터는 Protection을 지원하기 위해 존재.**

illegal 한 메모리 reference가 발생하면 하드웨어는 trap을 발생시켜서 OS에게 알려주고 그러면 OS는 그 프로세스를 kill하게 된다.

여기서는 '베이스'와 '바운드' 레지스터는 CPU 하나당 1쌍으로 존재하는 하드웨어 구조.

따라서 **물리 주소(Physical Address) = '베이스' 값 + 가상 주소(Physical Address)**

주소 변환에 도움을 주는 프로세서의 일부를 **메모리 관리 장치(Memory Management Unit, MMU)** 라고 부른다.

![img13](https://user-images.githubusercontent.com/35681772/59989797-98c98c00-967b-11e9-9a3c-76b90b03e50f.png)

![img18](https://user-images.githubusercontent.com/35681772/59989813-9f580380-967b-11e9-8d1a-8ea63b110179.png)

![img19](https://user-images.githubusercontent.com/35681772/59989827-a848d500-967b-11e9-95c4-cd4607867f38.png)

![img20](https://user-images.githubusercontent.com/35681772/59989838-aed74c80-967b-11e9-9ca6-2d2551de535f.png)

---

## 15.4 하드웨어 요구사항

![img48png](https://user-images.githubusercontent.com/35681772/59989845-b696f100-967b-11e9-8d6e-c2c7eb0b478d.png)

---

## 15.5 운영체제 요구사항

![img8](https://user-images.githubusercontent.com/35681772/59989855-bf87c280-967b-11e9-954b-8f1c351be2be.png)

운영체제의 요구사항 중 프로세스 전환 시 베이스와 바운드 쌍을 저장하고 복원할 때, 운영체제는 메모리에 존재하는 프로세스 별 자료구조 안에 이 값들을 저장한다. 이 자료구조를 **프로세스 구조체(Process Structure)** 또는 **프로세스 제어 블럭(Process Control Block, PCB)** 라고 부른다.

하드웨어와 OS가 하는일이 구분이 된다 : Translation - 하드웨어, 그에 대한 문제 발생시 - OS

---

## 15.6 최종 흐름

![img9](https://user-images.githubusercontent.com/35681772/59989861-c4e50d00-967b-11e9-9fcf-6430e93e4f9a.png)

**Base & Bound 또는 동적 재배치** 는

베이스 레지스터를 가상 주소에 더하고 생성된 주소가 바운드를 벗어나는지 검사하기 위한 간단한 하드웨어 회로만 추가하면 되기 때문에 효율적이다.

그러나, 재배치된 프로세스에서 힙영역과 스택영역 사이의 할당되었지만 사용되지 않는 공간은 단순히 낭비되고 있어 비 효율적이다. 이를 **내부 단편화(Internal Fragmentation)** 라 한다. 이를 방지하기 위해 **세그멘테이션(Segmentation)** 이라는 기술을 사용한다.

---

# 실습 코드 관련 fork()와 wait()의 차이 : figure <5.1> & <5.2>

PID : Process Identifier의 약자. 프로세스 별 고유번호.
  
fork() System Call : 프로세스 생성을 위해 OS가 제공하는 System Call 중 하나이다. fork()함수를 호출하게 되면, 호출한 프로세스는 자신을 복제해 새로 자기 자신과 동일한 작업을 수행하는 프로세스를 생성한다. 즉, 생성된 프로세스는 호출한 프로세스의 복사본이 된다. 이 때, 호출한 프로세스는 부모 그리고 새로 생성된 프로세스는 자식이라 부른다. 하는 작업만 동일할 뿐, 자식 프로세스는 자신만의 새로운 주소공간, 사용 레지스터, PC 값을 할당받는다. fork()를 호출하면 부모 프로세스는 자식 프로세스의 PID를 반환받고, 자식 프로세스는 0을 반환 받는다. 그래서 서로 다른 조건문(PID > 0 : 부모, PID = 0 : 자식)을 통과하게 된다. CPU 스케줄러에 따라 부모, 자식간의 작업 실행 순서가 가변적이다. 즉, 호출 대상과 무관하게 프로세스 실행 순서를 보장받을 수 없다.

wait() System Call : 부모 프로세스가 자식 프로세스의 종료를 대기해야 하는 경우 사용한다(또는 그와 비슷한 대기상황 등에). fork()는 앞서 언급한 것과 같이 부모, 자식 프로세스간 순서의 고정을 보장받지 못한다. 따라서 예제처럼 부모 프로세스(PID > 0)일 경우 실행되는 if문에서 wait을 걸어 둘 경우 혹시나 부모 프로세스가 CPU 스케줄러에 의해 더 먼저 실행 될 우선순위를 가졌더라도, 자식 프로세스가 먼저 실행되는 것을 기다린 뒤, 자기 자신(부모)를 실행한다.

---