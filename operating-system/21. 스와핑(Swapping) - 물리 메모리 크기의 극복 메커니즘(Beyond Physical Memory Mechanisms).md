# 21. Swapping; 물리 메모리 크기의 극복 : 메커니즘(Beyond Physical Memory: Mechanisms)

지금까지는 가상 주소 공간이 작아서 모두 물리 메모리에 탑재가 가능하다는 가정하에 여러 메커니즘들을 다뤘었는데 지금부턴 더 현실적으로 알아본다.

다수의 프로세스들이 동시에 각자 큰 주소 공간을 사용하고 있는 상황에서의 메커니즘을 알아보자. 모든 프로세스들이 각자 큰 주소 공간을 사용하고있기 때문에, 이를 가능케 하려면 메모리 계층에 *추가적인 레이어* 가 필요하다. 

그래서 **운영체제는 주소 공간 중에 현재는 크게 필요하지 않는 일부를 하드 디스크 드라이브 또는 SSD에 보관해 두게 된다.**

그렇다면 여기서 프로세스에게 굳이 '큰' 주소 공간을 제공해야 하는 이유는?? 편리함과 사용 용이성 때문이다.

주소 공간이 충분히 크면, 프로그램의 자료 구조들을 위한 충분한 메모리 공간이 있는지 걱정하지 않아도 되고, 필요시 운영체제에게 메모리 할당을 요청하면 된다. 이것이 가능한 이유는 운영체제가 '가상'환경을 제공하기 때문이다.

이러한 *추가적인 레이어 또는 공간* 을 **스왑 공간(Swap space)** 이라고 부르며, 스왑 공간을 추가하므로써 각 프로세스들에게 큰 가상 메모리 공간을 사용하는듯한 illusion을 주게 된다.

멀티프로그래밍 시스템(컴퓨터의 사용률을 높이기 위해 '동시에' 여러 프로그램들을 실행시키는 시스템)에서는 많은 프로세스들의 페이지를 물리 메모리에 전부 저장하는 것이 불가능하게 되어, 일부 페이지들을 디스크에 스왑 아웃(Swap out)하는 방식으로 유지가 된다. 따라서 운영체제는 스왑 공간에 있는 모든 페이지들의 디스크 주소를 기억해야 한다.

이러한 이유로 실제 물리 메모리보다 더 많은 용량의 메모리가 필요하게 되었다.

**Swap out    : 페이지를 메모리에서 스왑 공간으로**

**Swap in     : 페이지를 스왑 공간에서 메모리로**

---

## 21.1 스왑 공간(Swap space)

스왑 공간은 디스크에 페이지들을 저장할 수 있는 일정 공간을 말한다. 메모리의 크기가 제한적이므로 디스크에 메모리 페이지를 읽고 쓸 공간을 확보해 둔 것이다.

스왑 공간의 크기는 시스템이 사용할 수 있는 메모리 페이지의 최대수를 결정하기 때문에 매우 중요하다고 볼 수 있다.

![img1](https://user-images.githubusercontent.com/35681772/59990761-64f06580-967f-11e9-97dd-b7b7a44a823d.png)

위 예시에서 물리 메모리와 스왑 공간에는 4개의 프로세스들의 페이지가 들어가 있다. 현재 물리 메모리에는 프로세스 0, 1, 2가 탑재 돼 있고, 나머지는 스왑 공간 즉, 디스크에 스왑 아웃 되어 있으므로 현재 실행중이 아니다.

이처럼 **스왑 공간을 이용하여 실제 물리 메모리 capacity보다 더 많은 공간이 존재하는 것처럼 illusion을 줄 수 있다.**

또한 **스왑 공간에만 스왑을 할 수 있는것은 아니다.** 물리 메모리에 추가 공간을 확보해야 할 때, 코드 영역의 페이지들이 차지하는 물리 페이지는 즉시 다른 페이지가 사용할 수 있다. 해당 페이지들은 디스크에 원본이 있으므로, 언제든지 다시 swap in 이 가능하기 때문이다.

---

## 21.2 Present Bit

**특정 페이지가 물리 메모리에 존재하는지(Present Bit = 1), 물리 메모리에 존재하지 않고 디스크에 존재하는지(Present Bit = 0)를 나타내는 비트.**

메모리가 참조되는 과정을 다음과 같다.

![img2](https://user-images.githubusercontent.com/35681772/59990770-6e79cd80-967f-11e9-9082-d4e0e333e660.png)

  - 프로세스가 가상 메모리 참조를 생성한다.
  - 하드웨어는 메모리에서 원하는 데이터를 가져오기위해 가상 주소를 물리 주소로 변환한다.
  - 가상 주소에서 VPN을 추출한 후 TLB에 해당 정보가 있는지 검사한다.
    - TLB 히트시 물리 주소를 얻은 후 메모리로 가져온다. - 매우 빠름
    - TLB 미스시 하드웨어는 페이지 테이블의 메모리 주소를 파악(페이지 테이블 베이스 레지스터를 사용하여)하고, VPN을 인덱스로 하여 PTE를 추출한다.
      - 해당 페이지 테이블이 유효하고 그 페이지가 물리 메모리에 존재하면( **Present Bit = 1** ), 하드웨어는 PTE에서 PFN 정보를 추출하여 그 정보를 TLB에 탑재한 뒤 명령어를 재실행하여 TLB 히트를 유도한다.
      - *해당 페이지 테이블이 유효한데 그 페이지가 물리 메모리에 존재하지 않는다면( **Present Bit = 0** ), **페이지 폴트(page fault)** 가 발생* 한다. **페이지 폴트(page fault)** 발생 시, 운영체제로 제어권이 넘어가며 **페이지 폴트 핸들러(page fault handler)** 가 실행된다.

주목해야 할 부분은 TLB 미스시 어떤 경우로 나뉘는가 이다. TLB 미스 발생시 세 가지 경우로 나뉘게 된다.

  1) 페이지가 유효하고 물리 메모리에 존재하는 경우( **Present Bit = 1** ) : TLB 미스 핸들러가 PTE에서 PFN을 가져와서 명령어를 재시도 하여 TLB 히트를 유도한다.
  2) 페이지가 유효하지만 물리 메모리에 존재하지 않는 경우( **Present Bit = 0** ) : **페이지 폴트 핸들러** 가 실행되어 스왑 공간에서 메모리로 swap in 하게 된다. 그렇게 가져온 데이터는 명령어가 재 실행되어 TLB 미스를 거쳐 최종적으로 TLB 히트가 된다.
  3) 페이지가 유효하지 않은 경우 : 잘못된 주소를 접근하는 경우 등의 처리가 필요하다. 하드웨어는 이 경우 운영체제의 트랩 핸들러에 의해 처리되도록 한다.

이와같은 과정을 거치게 된다.

---

## 21.3 페이지 폴트(page fault)

**페이지 폴트** 발생시 운영체제가 그 처리를 담당한다. 운영체제의 **페이지 폴트 핸들러** 가 해당 페이지 폴트에 대한 처리 메커니즘을 규정한다.

만약 **요청된 페이지가 메모리에 없고 디스크에 있다면, 운영체제는 해당 페이지를 메모리로 스왑해온다.**

운영체제는 원하는 페이지의 위치 즉, 해당 페이지의 스왑 공간상에서의 위치를 페이지 테이블 상에서 PFN과 같은 _PTE비트들을 사용하여 디스크 주소를 찾을 수 있다._

따라서 페이지 폴트 발생 시, **운영체제는 PTE에서 해당 페이지의 디스크 상 위치를 파악하여 메모리에 탑재한다.**

디스크 I/O가 완료되면 운영체제는 해당 PTE의 PFN값을 탑재된 페이지의 메모리 위치로 갱신한다.

여기까지 완료되면 페이지 폴트를 발생시킨 명령어가 재실행된다. 재실행시 TLB 미스가 발생될 수 있고, 발생 하는 경우 TLB 미스 처리 과정에서 TLB값이 갱신된다. 그 후 TLB 히트가 발생하여 물리 주소로의 접근이 가능하게 된다.

I/O 전송 중에는 해당 프로세스가 blocked 상태이므로, 페이지 폴트 처리시 운영체제는 다른 프로세스들을 실행할 수 있다.

---

## 21.4 메모리에 빈 공간이 없으면?

메모리상 어떤 페이지를 swap out하고 새로운 페이지를 in 할지에 대한 이슈를 **'페이지 교체 정책'** 에서 다루게 된다.

---

## 21.5 페이지 폴트의 처리

![page_fault](https://user-images.githubusercontent.com/35681772/59990780-7d608000-967f-11e9-8f3f-24af2fe57c6b.jpg)

![img2-3](https://user-images.githubusercontent.com/35681772/59990787-84878e00-967f-11e9-976c-f6f1179c3069.png)

운영체제가 페이지 폴트를 처리하는 흐름은 위와 같다. 

먼저 운영체제는 탑재할 페이지를 위한 물리 프레임을 확보한다. 

만약 **메모리에 빈 공간이 없다면 메모리에서 페이지를 내보내고 여유 공간을 확보한다.** 

그 후 I/O 요청을 통해 스왑 공간에서 페이지를 읽어온다.

페이지를 읽어왔으면 페이지 테이블을 갱신하고 명령어를 재실행하여 TLB 미스를 거쳐 한번 더 명령어를 실행하여 TLB 히트까지 유도한다.


## 21.6 교체는 실제 언제 일어나는가

운영체제는 다양한 이유로 인해 메모리에 여유 공간이 고갈된 후에 교체 알고리즘을 작동시키는 것이 아니라 *항상 어느 정도의 여유 메모리 공간을 확보하고 있어야 한다.*

따라서 운영체제는 여유 공간에 관련된 **최댓값(high watermark, HW)** 과 **최솟값(low watermark, LW)** 을 설정하여 교체 알고리즘 작동에 활용한다.

*운영체제가 여유 공간의 크기가 최솟값보다 작아지면 여유 공간 확보를 담당하는 백그라운드 쓰레드(스왑 데몬(swap daemon) 또는 페이지 데몬(page daemon))가 실행되어 여유 공간의 크기가 최댓값에 이를 때까지 페이지를 제거한다.*

이렇게 백그라운드 쓰레드가 작동하여 충분히 여유 메모리를 확보하면 이 백그라운드 쓰레드는 슬립 모드로 들어간다.

많은 시스템들은 성능 개선을 위하여 다수의 페이지들을 **클러스터(cluster)** 또는 **그룹(group)** 단위로 묶어서 한 번에 스왑 파티션에 저장함으로써 디스크의 효율을 높힌다.

이 백그라운드 쓰레딩을 사용하게 되면 <그림 21.3>의 흐름이 약간 변경되어 *교체를 직접 수행하는 대신 알고리즘은 사용할 수 있는 페이지들이 있는지를 단순히 검사만 한다.*

만약 사용할 수 있는 페이지들이 없다면 백그라운드 페이징 쓰레드에게 여유 페이지들이 필요하다고 알려주고 해당 쓰레드가 페이지들을 비운 후에 원래의 쓰레드를 다시 깨워서 원하는 페이지를 불러들일 수 있도록 한다.

---

## 21.7 요약

스와핑의 아이디어는 시스템에 실제 존재하는 물리 메모리의 크기보다 더 많은 메모리를 사용해보겠다는 것이다.

**present bit** 은 메모리에 특정 페이지가 존재하는지를 알려준다.

운영체제는 **페이지 폴트(page fault)** 를 처리하기 위해 **페이지 폴트 핸들러(page fault handler)** 를 작동시킨다. **핸들러** 는 원하는 페이지를 디스크에서 메모리로 전송하기 위해 메모리의 일부 페이지들을 먼저 교체하여 새롭게 스왑되서 들어올 페이지를 위한 공간을 만드는 일을 한다.

이 모든 작동들은 프로세스가 인지하지 못하는 상황에서 처리된다. 프로세스는 자기가 자신만의 큰 가상 메모리를 사용하고 있다는 illusion에 빠져있다. 실제로는 앞서 다룬 내용과 같이 페이지들은 물리 메모리 및 디스크에 뿔뿔이 흩어져 있다.

---
