
# 19. 페이징(Paging) : 더 빠른 변환(Faster Translations (TLB))

페이징은 상당한 성능 저하를 초래할 수 있다. 프로세스 주소 공간을 작은 고정된 크기(=페이지)로 나누고, 각 페이지의 실제 위치(매핑 정보, mapping information)를 메모리에 저장한다. 이러한 매핑 정보를 저장하는 자료구조를 '페이지 테이블'이라 한다. 그런데 이 매핑 정보를 읽어들일 때 페이지 테이블 접근을 위한 메모리 읽기 작업은 엄청난 성능 저하를 유발한다. 따라서 이를 개선하기위해 하드웨어의 도움을 받아 TLB를 두게 되었다.

---

### **TLB(Translation-Lookaside Buffer)**

![4](https://user-images.githubusercontent.com/35681772/59990356-c1eb1c00-967d-11e9-93e9-ce035bc645b0.jpg)

- 빠른 주소 변환을 위해 도입된 하드웨어
- MMU(Memory-Management Unit)의 일부
- 자주 참조되는 가상 주소-실제 주소 변환 정보를 저장하는 하드웨어 캐시(주소 변환 캐시, **Address Translation Cache** )

가상 메모리 참조 시 하드웨어는 먼저 TLB에 원하는 변환 정보가 있는지를 확인하고, 있다면 페이지 테이블을 거치지 않고 변환을 빠르게 수행한다. TLB를 도입함으로써 페이징 성능을 엄청나게 향상시켜 페이징 기법이 사용 가능한 가상 메모리 기법이 되게 된다.

---

## 19.1 TLB의 기본 알고리즘

![img9](https://user-images.githubusercontent.com/35681772/59990362-c9aac080-967d-11e9-9ad9-a0150a32c1b6.jpg)

- TLB는 캐시의 설계 철학처럼 "주소 변환 정보가 대부분의 경우 캐시에 있다" 라는 가정을 전제로 만들어졌다.
- 성공하는 경우(히트) TLB는 프로세싱 코어와 가까운 곳에 위치하고 있고, 매우 빠른 하드웨어로 구성되기 떄문에 주소 변환 작업이 큰 부담없이 수행된다.
- 그러나 미스가 발생하는 경우 페이지 테이블을 접근하여(메모리 접근) 변환 정보를 찾아야 하므로 페이징 비용이 커지게 된다.
- 메모리 접근 연산은 다른 CPU연산에 비해 매우 시간이 오래 걸린다.
- 미스의 경우 Physical Address 직접 계산하지 않고, TLB에 이 instruction을 넣어버리고 다시 실행시킨다. 재실행시 히트가 날 것이기 때문.

캐시는 어떤 메모리 hierarchy 상에서도 만들 수 있다. 따라서 디스크에서도 캐시를 구성해둘 수 있음.

---

## 19.2 예제 : 배열 접근

![img10](https://user-images.githubusercontent.com/35681772/59990380-e1824480-967d-11e9-8fd4-1cb4bbdf1055.jpg)

- 가상주소 100번지부터 10개의 4바이트 정수 배열에 접근하는 경우 하드웨어는 VPN을 추출하여 06이라는 값을 얻는다.
- 하드웨어는 먼저 TLB에서 해당 VPN을 검색하지만 첫 접근이라 TLB 미스가 발생한다. 따라서 해당 VPN 06번에 대한 물리 페이지 번호를 찾아 TLB를 갱신한다.
- 그 다음 항목은 첫 번째 항목과 같은 페이지에 존재하기 때문에(공간 지역성) TLB 히트가 발생하게 된다. 필요한 변환 정보가 이미 TLB에 탑재되어 있다.
- 마찬가지로, 다음 VPN으로 넘어오는 경우 다시 미스가 발생하지만, 그 이후의 같은 페이지에 존재하는 항목에 대해서 히트가 발생하게 된다.

TLB의 성능에 영향을 미치는 요소로는 다음과 같은 것들이 있다.

- *공간 지역성(Spatial Locality)* : 같은 페이지 내에 위치해 있는 경우(예. 배열이 일렬로 공간을 차지하게 되어 같은 페이지 내에서 시작 참조 이후로는 TLB 히트 발생) - 어떤 대상이 참조되면 그 주변 대상들도 참조 될 것이다
- *시간 지역성(Temporal Locality)* : 한번 참조된 메모리 영역이 짧은 시간 내에 재 참조될 경우(예. 해당 배열에 재 접근시) - 한번 참조된 대상은 일정 시간 내에 또 참조 될 것이다

다른 캐시와 마찬가지로 TLB의 성공 여부는 프로그램의 공간 지역성과 시간 지역성 존재 여부에 달려있다.

### cf) 캐싱 : _"일반적인 경우를 빠르게 (Make the common case fast)"_

- 컴퓨터 시스템에서 사용되는 가장 근본적인 성능 개선 기술들 중 하나.
- 공간 지역성(Spatial locality)과 시간 지역성(Temporal locality)를 활용하여 더욱 빠른 접근을 가능토록 한다.
- 공간 지역성 : 프로그램이 메모리 주소 x를 읽거나 쓰면, x와 인접한 메모리 주소를 접근할 확률이 높다는 사실에 근거(배열을 순차적으로 읽는 경우)
- 시간 지역성 : 최근에 접근된 명령어 또는 데이터는 곧 다시 접근될 확률이 높다는 사실에 근거
- 모든 하드웨어 캐시의 목적은 필요한 메모리 내용을 매우 빠른 CPU 칩 내의 메모리에 위치시키고, 접근 지역성을 최대한 활용하는 것.
- CPU가 메모리 내용을 참조할 때, 상대적으로 느린 메모리를 직접 접근하는 것이 아니라, 우선 캐시에 사본이 있는지를 먼저 확인한다.
- 캐시는 "작기 때문에 빠른것이다" 즉, 초대형 캐시를 제작하여 사용하게 될 경우 캐시의 취지가 무색해진다. 캐시가 캐시 역할을 하기 위해서는 작아야만 하는 것.

---

## 19.3 TLB 미스는 누가 처리할까

**CISC(Complex Instruction Set Computers)** : 하드웨어가 TLB 미스를 처리하는 컴퓨터 구조. 이를 위해 하드웨어는 페이지 테이블에 대한 명확한 정보(메모리 상 위치(PTBR)와 정확한 형식)를 알고 있어야 한다. 인텔 x86 CPU가 _멀티 레벨 페이지 테이블(Multi Level Page Table)_ 을 사용하여 TLB를 하드웨어로 관리하는 대표적인 예다. 미스 발생시 하드웨어는 
  1) 페이지 테이블에서 원하는 페이지 테이블 엔트리를 찾고 
  2) 필요한 변환 정보를 추출하여 
  3) TLB를 갱신한 후 
  4) TLB 미스가 발생한 명령어를 재실행한다(그럼 그 떈 히트가 나겠지).

![img10](https://user-images.githubusercontent.com/35681772/59990385-e941e900-967d-11e9-988a-37252ca18e3c.png)

**RISC(Reduced Instruction Set Computing)** : 소프트웨어(운영체제)가 TLB 미스를 처리하는 컴퓨터 구조. 소프트웨어 관리 TLB(Software-managed TLB)를 사용한다. MIPS나 SUN사의 제품들이 대표적인 예다. 미스 발생시 
  1) TLB에서 주소를 찾는것에 실패하면 하드웨어는 예외(exception)을 발생시킨다(11번째 줄 else문). 
  2) 예외 시그널을 받은 운영체제는 명령어 실행을 중지하고 실행모드를 커널모드로 변경하여 커널 코드 실행을 준비한다. 커널 주소 공간을 접근할 수 있도록 특권 레벨(Privilege level)로 상향 조정을 하기 위함. 
  3) 그 후 커널 모드에서 TLB 미스의 처리를 담당하는 운영체제 코드인 **트랩 핸들러(Trap handler)** 를 실행한다. 이 트랩 핸들러는 페이지 테이블을 검색하여 변환 정보를 찾고, TLB 접근이 가능한 특권 명령어(Privileged Instruction)를 사용하여 TLB를 갱신한 후 리턴한다. 
  4) 트랩 핸들러에서 리턴되면 하드웨어가 명령어를 재실행한다.

- 여기서 두가지 관전포인트가 존재한다.

  - TLB 미스를 처리하는 트랩 핸들러는 시스템 콜 호출 시 사용되는 트랩 핸들러와 다르다. 시스템 콜 호출의 경우 트랩 핸들러에서 리턴 후 시스템 콜을 호출한 명령어의 '다음' 명령어를 실행한다. 그러나 TLB 미스를 처리하는 트랩 핸들러의 경우 트랩에서 리턴하면 트랩을 발생시킨 명령을 '다시' 실행해야 한다. 운영체제는 TLB 미스 트랩이 발생하면 트랩 핸들러가 종료되었을 때 다시 실행할 명령어 주소(Program Counter 값)를 저장한다. 즉, _운영체제는 트랩 발생의 원인에 따라 현재 명령어의 PC값을 저장할 지 혹은 다음 명령어의 PC값을 저장할 지 판단할 수 있어야 한다._
  - TLB 미스가 무한 반복(TLB 미스 핸들러를 접근하는 과정에서 TLB 미스가 발생)되지 않도록 해야 한다. 이를 위해 아래와 같은 솔루션이 있다.

    - TLB 미스 핸들러를 물리 메모리에 위치시켜 TLB 미스 핸들러의 주소가 핸들러의 '물리'주소로 표시되게 함으로써 주소 변환이 필요없게끔 한다(해당 TLB 미스 핸들러는 unmap되어 있으므로).
    - TLB 일부를 핸들러 코드 주소를 저장하는 데 영구히 할당함으로써 TLB 핸들러가 항상 TLB에서 히트되게 한다. 이를 _연결(Wired) 변환_ 이라 한다.
- TLB를 소프트웨어로 관리하는 방식은 다음과 같은 장점이 있다.
  - 유연성(Flexibility) : 운영체제는 하드웨어 변경 없이 페이지 테이블 구조를 자유로이 변경할 수 있다.
  - 단순성(Simplicity) : 미스가 발생하였을 때 TLB 미스 핸들러가 처리하므로, 하드웨어가 별도의 작업을 하지 않아도 된다.

---

## 19.4 TLB의 구성 : 무엇이 있나?
하드웨어 TLB의 경우 일반적으로 32, 64, 128개의 엔트리를 가지며 *완전 연관(Fully Associative)* 방식(변환 정보는 TLB 내 어디든 위치, 탐색시 TLB 전체에서 병렬적으로 수행)으로 설계된다. 

![img11](https://user-images.githubusercontent.com/35681772/59990398-f4951480-967d-11e9-8553-d0b4f535d951.jpg)

  - 각 항목마다 가상 페이지 번호(VPN), 물리 페이지 번호(PFN)을 둬서 변환 주소를 찾을 때, 하드웨어는 TLB 각 항목을 동시에 검색하게 된다.
  - TLB 항목 중 다른 비트들에는 Valid bit, Protection bit, Address-space Identifier, Dirty bit 등이 있다.

---

## 19.5 TLB의 문제 : Context Switch

![5](https://user-images.githubusercontent.com/35681772/59990403-fb238c00-967d-11e9-8613-6aac17e2722c.jpg)

TLB에 있는 가상 주소와 실제 주소간의 변환 정보는 그것을 탑재시킨 프로세스에서만 유효하다. 따라서 새로운 프로세스에서는 이전에 실행하던 프로세스의 변환 정보를 사용하지 않아야 한다.

![img11](https://user-images.githubusercontent.com/35681772/59990411-0080d680-967e-11e9-8db1-b9cbd2aa3739.png)

  - 위의 예시에서 좌측의 경우 두개의 프로세스가 동일한 VPN값을 가지고 다른 PFN값을 참조하고 있다. 하지만 구별이 되지 않으므로 Context Switching이 발생 시 문제가 발생한다. 
  - 이 문제를 해결하기 위해 Context Switching이 발생할 때 다음 프로세스가 실행되기 전 기존 TLB 내용을 비우는 방법이 있으나, 이는 새로운 프로세스가 실행될 때 데이터와 코드 페이지에 대한 접근으로 인한 TLB 미스 발생을 초래한다.
  - 따라서 우측과 같이 **ASID(주소 공간 식별자. Address Space Identifier)** 를 둬서 프로세스간 TLB 변환 정보를 구별을 둘 뿐 아니라, 프로세스들이 TLB의 공간을 공유할 수 있게끔 하였다.

![img12](https://user-images.githubusercontent.com/35681772/59990416-0676b780-967e-11e9-807e-b65161788e6a.png)

  - 이 경우 두개의 프로세스들이 하나의 페이지(ex. 코드 페이지, PFN 101)를 공유하게끔 하여 사용되는 물리 페이지의 수를 줄이고 메모리 부하를 줄이게끔 하였다.
  - VPN이 다르더라도 PFN을 쉐어해서 메모리를 절약할 수 있다.

---

## 19.6 이슈 : 교체 정책(Replacement Policy)

![6](https://user-images.githubusercontent.com/35681772/59990426-0c6c9880-967e-11e9-81cf-4b7245877d00.jpg)

캐시 교체(Cache Replacement)의 이슈가 존재하는데, 한정된 공간인 TLB에 새로운 항목을 탑재할 때, 현존하는 항목 중 어떤 하나를 교체 대상으로 선정할지에 대한 것이다. 미스율을 감소(히트율을 증가)
시키는 방향으로 성능이 개선되며 교체가 이루어 져야 한다. 여기엔 아래와 같은 방법들이 존재한다.

  - 최저 사용 빈도(Least-Recently-Used, LRU) 항목을 교체 : 합리적인 방법으로 지역성을 최대한 활용하는 것. 그러나 때때로 최악의 TLB 미스를 생성할 수 있음.
  - 랜덤(Random) 정책 : 교체 대상을 무작위로 선정. 구현이 간단하고 예상치 못한 예외 상황의 발생을 피할 수 있음.

---

## 19.7 실제 TLB

![img13](https://user-images.githubusercontent.com/35681772/59990432-12fb1000-967e-11e9-9ac7-6fa4edf8f279.png)

  - 소프트웨어로 관리되는 TLB를 사용하는 MIPS R4000을 예시로 들고있다.
  - 전체 주소 공간의 절반만 사용자 주소 공간으로 할당되어있고 나머지 반은 커널이 사용한다.
  - G(Global) 비트 : 전역 비트. 프로세스들 간에 공유되는 페이지들을 위해 사용. 설정되어 있을시, ASID는 무시된다.
  - ASID 필드(8비트) : 운영체제가 주소 공간들을 서로 구분하도록 해주는 비트.
  - C(Coherence) 비트 : 일관성 비트. 페이지가 하드웨어에 어떻게 캐시되어 있는지를 판별하게 해주는 비트.
  - 그 외 Dirty, Valid 비트 등이 있다.
  - MIPS의 TLB들은 대부분 사용자 프로세스들이 사용하지만, 몇 개는 운영체제를 위해 예약 되어 있다. 운영체제는 예약된 매핑 영역을 TLB 미스가 발생해서는 안되는(ex. TLB 미스 핸들러) 코드와 데이터를 위해서 사용한다.
  - MIPS에서는 TLB를 갱신하기 위한 명령어(TLBP, TLBR, TLBWI, TLBWR)이 존재하는데, 이 명령어들은 특별한 실행권한(Privileged)을 가지고 있어야 한다.

---

## 19.8 요약
주소 변환을 더 빠르게 처리하기 위한 TLB(Translation-Lookaside Buffer)에 대해 알아보았다. TLB를 주소 변환 캐시로 사용함으로써
  - 대부분의 메모리 참조들은 메인 메모리 상의 페이지 테이블을 읽지 않고도 처리가 가능하게 되었고
  - 프로그램들은 메모리 가상화 기능이 없는 것과 동일한 성능을 보일 수 있게 되었다.

하지만 한계도 존재한다.
  -  Exceeding the TLB coverage : TLB 범위를 벗어나는 경우. 프로그램이 짧은 시간 동안 접근하는 페이지들의 수가 TLB 유효 범위보다 많은 경우. 이 경우 더 큰 페이지들을 제공하여 TLB의 유효 범위를 늘려 개선한다. 이러한 더 큰 페이지들을 지원하는 것은 DBMS(Database Management System)과 같은 프로그램에 의해 주로 사용된다.
  - 물리적으로 인덱스된 캐시(Physically-Indexed Cache) : CPU 파이프라인에서 TLB 접근이 병목(Bottleneck)이 되는 경우. 주소 변환이 캐시 '접근 전'에 이루어져야 하는데 이 경우 속도 저하를 초래할 수 있다. 이는 가상적으로 인덱스된 캐시(Virtually-Indexed Cache)로 개선이 일부 가능하다.

  ---