
# 17. 빈 공간 관리(Free-Space Management)

가변크기의 빈 공간들로 인해 발생하는 External fragmentation를 최소화하고자 어떤 전략들을 사용할 것인지.

---

## 17.1 가정(Assumptions)

- malloc()과 free()와 같은 함수를 가지고 예시를 들어 설명한다. 이 라이브러리가 관리하는 공간은 힙(heap)이 되며, 힙의 빈공간을 관리하는 데는 일반적으로 링크드리스트가 사용된다.
- 또한 클라이언트에게 할당된 메모리는 다른 위치로 재배치될 수 없다고 가정한 상태로 알아보도록 한다. 이 경우 Fragmentation에 유용하게 사용되는 빈 공간의 압축은 사용이 불가능하다.

---

## 17.2 저수준 기법들(Low-level Mechanisms)


### 1) **분할과 병합(Splitting and Coalescing)**

![img8](https://user-images.githubusercontent.com/35681772/59990063-b519f880-967c-11e9-8010-c5d1a03f6eaa.png)

- **분할** : 위와같은 30바이트의 힙이 있다고 가정했을 때, 빈 공간 리스트에는 0번 주소와 20번 주소를 담고 있게 된다. 이 때, 각 메모리의 크기는 10바이트 씩 이지만 1바이트 만큼의 요청이 온 경우 아래와 같이 둘 중 하나의 공간을 선택하여 두개의 영역으로 분할 하여 1바이트를 할당함. 요청이 특정 빈 공간의 크기보다 작을 경우 분할 기법을 사용.

![img9](https://user-images.githubusercontent.com/35681772/59990069-bb0fd980-967c-11e9-8417-f8af8b16601e.png)

- **병합** : 위와같은 30바이트의 힙에서, 사용중이었던 10번주소의 공간이 free되었을 때, 빈 공간 리스트에는 아래와 같이 10바이트씩 분할된 공간으로 자리잡게 된다. 그러나 이 경우 30바이트의 여유 공간이 있음에도, 10바이트씩 분할되어 그것보다 큰 크기의 요청에 대해 처리할 수 없게된다. 따라서 메모리 청크(Chunk)를 반환할 때 인접한 빈 공간 주소를 참조하여 새로 해제된 빈 공간이 인접한 경우 더 큰 빈 공간으로 병합하는 것을 말한다.

![img11](https://user-images.githubusercontent.com/35681772/59990074-c105ba80-967c-11e9-8439-cd8341949d82.png)


### 2) **할당된 공간의 크기 파악(Tracking The Size Of Allocated Regions)**

![img12](https://user-images.githubusercontent.com/35681772/59990079-c7943200-967c-11e9-9332-d25f7b30cf12.png)

free를 할 경우 해제되는 메모리 영역의 크기를 알아서 파악하여 빈 공간 리스트에 추가시킨다. 그게 가능한 이유가 바로 할당에 필요한 추가적인 정보를 **헤더(header) 블럭** 에 저장하게 되기 때문이다.

헤더에는 할당된 공간의 크기를 저장하는 정보(size)와 무결성 검사를 제공하기 위한 매직 넘버(magic) 등을 저장할 수 있고, 사용자가 free를 호출하여 헤더를 가리키는 포인터를 얻어내면 매직 넘버를 통한 안전성 검사 이후 새로 해제된 영역의 크기를 계산하게 된다.

영역의 크기를 계산할 때, 헤더의 크기도 포함이 된다. 즉, **헤더 크기 + 사용자에게 할당된 영역의 크기** 이다. 사용자가 N 만큼의 공간을 요청하더라도, 자동으로 헤더 크기까지 더해진 영역의 크기를 고려하게 된다.


### 3) **빈 공간 리스트 내장(Embedding A Free List)**

![img14](https://user-images.githubusercontent.com/35681772/59990088-d24ec700-967c-11e9-93d8-1b7b2fc0b030.png)

힙은 위 그림과 같이 자기 공간을 확보 및 해제하는 과정을 거친다.

여기서 맨 오른쪽과 같이 더이상 할당된 공간이 없음에도 분할되어 존재하는 문제가 발생하게 된다. 이는 리스트를 순회하면서 인접한 청크를 병합하는 과정을 거쳐 해결할 수 있다.


### 4) **힙의 확장(Growing The Heap)**

힙 공간이 부족한 경우 실패(NULL)을 리턴한다.

대부분의 Allocator들은 힙을 할당할 때, 적은 크기의 힙으로 시작하여 그 공간을 다 쓰면 특정 시스템 콜(Unix 시스템에서는 sbrk)을 호출하여 운영체제에게 더 많은 메모리를 요청한다. 운영체제는 해당 요청을 수행하기 위해 빈 물리 페이지를 찾아 요청 프로세스의 주소 공간에 매핑한 후 새로운 힙의 마지막 주소를 반환한다. 그러면 Allocator는 확장된 영역에서 새로운 청크를 할당하게 되며 더 큰 힙을 사용할 수 있게 된다.

---

## 17.3 기본 전략(Basic Strategies) : 빈 공간 할당을 위한 기본 전략들에 대한 내용

![base](https://user-images.githubusercontent.com/35681772/59990118-eeeaff00-967c-11e9-9a5f-56afe287555e.png)
<br><br>


### 1) **최적 적합(Best Fit)**

![Best](https://user-images.githubusercontent.com/35681772/59990098-db3f9880-967c-11e9-84c2-0148227ff4b5.png)

- 빈 공간 리스트의 공간 중 요청받은 크기와 같거나 더 큰 공간을 찾음.
- 그 공간들 중, 가장 작은 크기의 청크를 가져온다(최적 청크).
- 따라서 빈 공간 리스트를 한 번 순회하면 최적 청크를 찾을 수 있다.
- 그러나 항상 전체를 탐색해야 하기 떄문에 엄청난 성능 저하를 초래할 수 있다.
- 위 예시에서 크기 15인 요청이 들어왔을 시, 요청을 만족시킬 수 있는 청크 중 가장 작은 20을 선택하고(세번째 공간) 20 → 5 로 변경되어 위와같이 공간이 존재하게 됨.


### 2) **최악 적합(Worst Fit)**

![Worst](https://user-images.githubusercontent.com/35681772/59990132-f90cfd80-967c-11e9-9b48-e9d656417ee1.png)

- 최적 적합의 반대방식.
- 가장 큰 빈 청크를 찾아 요청받은 크기만큼만 반환하고, 나머지는 빈 공간으로 유지.
- 마찬가지로 전체를 탐색해야 하기 때문에 성능 저하 + 엄청난 Fragmentation 이슈가 존재.
- 위 예시에서 크기 15인 요청이 들어왔을 시, 30을 선택하고 그 후 위와같이 빈 공간이 존재하게 됨.


### 3) **최초 적합(First Fit)**

![Worst](https://user-images.githubusercontent.com/35681772/59990132-f90cfd80-967c-11e9-9b48-e9d656417ee1.png)

- 요청받은 크기보다 큰 첫번째 빈 공간을 해당 요청만큼 반환하고 남은 빈 공간은 빈 공간 리스트에 다시 유지시킨다.
- 이 최초 적합 알고리즘은 속도가 빠르다.
- 그러나, 빈 공간 리스트의 시작부분에 크기가 작은 객체가 많이 생길 경우 탐색에 소요되는 시간이 증가하여 제 성능을 발휘하지 못할 수 있는데 이는 **주소기반 정렬(Address-based ordering)** 을 사용하여 리스트를 주소로 정렬하고 병합을 쉽게하여 Fragmentation를 감소시킴으로써 개선할 수 있다.
- 위 예시에서 크기 15인 요청이 들어왔을 시, 30을 선택하고 그 후 위와같이 빈 공간이 존재하게 됨. 최악 적합과 동일한 결과를 도출하지만 탐색에 소요되는 비용적인 측면에서 최초 적합은 30까지만 탐색한 후 그 빈 공간을 리턴하기 때문에 탐색 비용이 감소된다.


### 4) **다음 적합(Next Fit)**

- 빈 공간 탐색을 리스트 전체에 더 균등하게 분산시키기 위해, 마지막으로 찾았던 원소를 가리키는 추가의 포인터를 유지하는 알고리즘이다.
- 리스트의 처음 부분에만 Fragmentation이 집중하는것을 방지한다.
- 이 알고리즘은 전체 탐색을 하지 않아 최초 적합(First Fit)방식과 성능이 유사하다.

---

## 17.4 다른 접근법(Other Approaches)

### 1) 개별 리스트(Segregated List) : 특정 응용 프로그램이 한두 개의 자주 요청하는 크기가 있다면, 그 크기의 객체를 관리하기 위한 별도의 리스트를 유지하는 것. 그 외 다른 요청들은 일반 Allocator에 전달된다.

장점 : 특정 크기의 요청을 위한 메모리 청크를 유지함으로써 Fragmentation의 가능성을 줄인다. 또, 요청 된 크기에 해당하는 리스트에서 탐색을 하므로 할당과 해제 요청에 신속하게 대응할 수 있다.

단점 : 지정된 크기의 메모리 풀과 일반 풀에 얼마만큼씩 메모리를 할당할 지에 대한 이슈가 제기된다. 이는 **슬랩 할당기(Slab Allocator)** 로 개선할 수 있다.
- 슬랩은 하나 이상의 연속된 물리 페이지로 구성되어 있으며 일반적으로 하나의 페이지로 구성된다. 캐시는 이러한 슬랩들의 복수개로 구성된다.
- 커널이 부팅될 때 커널 객체를 위한 객체 캐시(Object Cache)들을 할당한다. 커널 객체는 락, 파일 시스템, 아이노드 등의 자주 요청되는 자료구조들을 지칭한다. 따라서 락 구조만을 담고 있는 객체 캐시, 아이노드로만 구성된 객체 캐시등이 존재하는데, 이런 객체 캐시를 위한 공간이 부족하면 상위 메모리 할당기(Memory Allocator)에게 추가 슬랩을 요청한다. 반대로 객체들에 대한 참조 횟수가 0이 되면 해당 슬랩을 회수할 수도 있다.
- 슬랩 할당 방식은 빈 객체들을 사전에 초기화된 상태로 유지하게 되어 자료구조들의 초기화와 반납에 소요되는 작업들을 피할 수 있어 오버헤드를 현저히 감소시킨다(시간 소요↓).

### 2) 버디 할당(Buddy Allocation)

![buddy](https://user-images.githubusercontent.com/35681772/59990188-2c4f8c80-967d-11e9-95e3-9e5f52a0f8e8.png)

**Allocator의 주 역할은 빈 공간의 합병** 이므로 다른 여러 방법들이 나왔는데 그 중, **이진 버디 할당기(Binary Buddy Allocator)** 가 있다.

최초 빈 메모리를 2^N 개념의 공간으로 설정하고, 요청받은 공간 크기에 적합한 사이즈로 이진 분할 한다. 위 예시에서 7KB의 요청이 들어왔을 시 8KB까지 공간을 이진 분할한 뒤(더 분할할 경우 요청을 담을 수 없음) 사용자에게 리턴한다.

블럭이 해제될 때, 해당 블럭과 동일한 사이즈의 '버디'가 비어있는지 확인하고 그렇다면 두 블럭을 합병한다. 이렇게 트리를 따라 재귀 합병 과정을 거쳐 빈 공간을 회수하게 된다.

이렇게 공간을 할당할 경우 앞서 할당된 공간과 한 비트만 다른 주소에 요청이 할당되므로 특정 블럭의 버디를 결정하는것이 쉬워지게 된다.

### 기타 아이디어

**'확장성(Scaling)'** 이라는 이슈때문에 빈 공간들의 개수에 따라 리스트 탐색이 느려지게 된다. 따라서 균형 이진 트리(Balanced Binary Tree), 스플레이 트리(Splay Tree) 등의 자료구조를 사용하여 시간에 대한 비용을 줄이려는 노력들이 더해지고 있다.

---

## 17.5 요약(Summary)

앞서 다룬 메모리 할당기(Memory Allocator)에는 다양한 워크로드에 대해 빠르고 효율적이고 확장성이 좋은(Scalable) 할당기를 만드는 이슈가 여전히 존재해 숙제로 남아있음.

---