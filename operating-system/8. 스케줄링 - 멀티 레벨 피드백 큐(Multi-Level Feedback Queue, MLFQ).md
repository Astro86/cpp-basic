
# 8. 스케줄링 : 멀티 레벨 피드백 큐(Multi-Level Feedback Queue, MLFQ)

MLFQ는 다음과 같은 이유에서 등장하게 되었다.
  - 짧은 작업을 먼저 실행시켜 소요시간(turnaround time)을 최적화한다 : CPU Bound Job을 해결하고자
  - 응답시간(response time)을 최적화한다 : Interactive Job을 해결하고자
  - 즉, 두마리 토끼를 다 잡겠다는 것.

작업의 실행 시간에 대한 사전 정보 없이 interactive한 작업의 응답 시간을 최소화하고 동시에 반환 시간을 최소화 하는 스케줄러를 어떻게 설계할지가 이번 주제에서의 관전 포인트.

---

## 8.1 MLFQ : 기본 규칙 - 각 job들의 length를 모르는 상황이라 '우선 순위'개념을 도입

MLFQ는 각기 다른 우선순위(priority level)를 가진 여러개의 큐로 구성된다.

  - **<규칙 1> : 프로세스들은 이러한 큐 들에 존재하며, 우선순위가 높은 큐에 들어있는 프로세스가 먼저 실행된다.**
  - **<규칙 2> : 큐에는 둘 이상의 작업이 존재할 수 있고, 둘은 같은 우선순위를 갖는다. 같은 우선순위를 가진 작업들 사이에선 라운드 로빈(RR) 스케줄링 알고리즘이 사용된다.**

![image10](https://user-images.githubusercontent.com/35681772/59988869-a5e47c00-9677-11e9-9b15-32da6fde5c9a.jpg)

**MLFQ는 각 프로세스의 특성에 따라 동적으로 우선순위를 부여한다.** 예를 들어 어떤 작업이 I/O를 주기적으로 요청하여 CPU를 반납한다면 MLFQ는 해당 작업의 우선순위를 높게 유지한다. 반면 어떤 작업이 긴 시간 동안 CPU를 집중적으로 사용한다면 MLFQ는 해당 작업의 우선순위를 낮춘다.

MLFQ는 프로세스가 실행되는 동안 해당 프로세스의 정보를 얻고 이 정보를 이용하여 미래 행동을 예측한다.

![img3](https://user-images.githubusercontent.com/35681772/59988885-b0067a80-9677-11e9-89f2-ad727b7b8058.png)

MLFQ는 이런 형태로 작업을 유지한다. 여기서 작업 A, B는 가장 높은 우선순위에 존재하고 그 다음으로 작업 C, 작업 D 순이다. 만약 아무런 조치도 취하지 않는다면 우선순위가 밀린 작업 C와 D는 실행이 되지 않게 된다. 따라서 이를 개선하기 위해 다음과 같은 시도들이 존재.

---

## 8.2 시도 1 : 우선순위의 변경
MLFQ가 작업의 우선순위를 바꿔주지 않는다면 낮은 우선순위에 있는 프로세스들은 실행되지 않는 상황이 올 수 있다. 따라서 우선순위 조정 알고리즘이 필요하게 된다.

  - **<규칙 3> : 작업이 시스템에 진입하면, 가장 높은 우선순위를 갖는다. 즉, 가장 위의 큐에 놓여진다.**
  - **<규칙 4a> : 타임 슬라이스(Time Slice)를 모두 사용하면 우선순위는 낮아진다. 즉, 한 단계 아래 큐로 이동한다.**
  - **<규칙 4b> : 타임 슬라이스를 모두 사용하기 전에 CPU를 양도하면(놓아주면) 같은 우선순위를 유지한다.**
 
![image11](https://user-images.githubusercontent.com/35681772/59988891-b98fe280-9677-11e9-82ea-402028fda518.jpg)

스케줄러는 작업이 짧은 작업인지 긴 작업인지 알 수 없기 때문에 일단 짧은 작업이라고 가정하여 높은 우선순위를 부여한다. 그게 진짜 짧은 작업일 경우 빨리 실행되고 바로 종료된다. 짧은 작업이 아닌 경우 천천히 더 아래 큐(낮은 우선순위의 큐)로 이동하게 된다. 이런 방식으로 MLFQ는 SJF를 구현 해 낸다.
  
![image12](https://user-images.githubusercontent.com/35681772/59988908-c44a7780-9677-11e9-962b-d08314fe2a9c.jpg)

첫번째 예시의 경우 긴 실행시간을 가진 작업이다. 작업이 우선 들어오면 높은 우선순위에 배정되어 정해진 time-slice동안 실행된 뒤 우선순위가 하락한다. 그렇게 가장 낮은 우선순위까지 내려가서 실행되게 된다.

두번째 예시의 경우 2개의 작업이 존재하는데, A는 오래 실행되는 CPU 위주의 작업이고 B는 짧은 대화형 작업이다. A는 꽤 실행해 온 상태이고 그 도중 B가 들어왔을경우 두번째 그림처럼 실행이 되게 된다. A는 이미 실행해 온 상태이기 때문에 가장 낮은 우선순위에 존재하고, B는 새로 실행이 되며 가장 높은 우선순위에서 배정되어 A의 작업이 중단된 다음 B를 먼저 실행시키게 된다.
  
이 예에서 MLFQ의 주요 목표를 알 수 있다. MLFQ는 각 작업이 짧은지 긴지 알 수 없기 때문에 일단 짧은 작업이라고 가정하여 높은 우선순위를 부여하며 실행시키게 된다. MLFQ가 어떻게 SJF에 근접할 수 있는지 확인할 수 있다.

세번째 예시의 경우 I/O 작업이 발생한 경우인데, <규칙 4b>에 따라 회색 작업은 입출력을 수행하기 전 짧은 시간동안만 실행되고 CPU를 양도하기 때문에 같은 우선순위를 유지하고 있다.

현재까지의 MLFQ의 문제점
  - 기아 상태(starvation) : 시스템에 너무 많은양의 interactive형 작업들이 존재하는 경우 긴 실행 시간을 요구하는 작업은 CPU를 할당받지 못하게 되는 현상.
  - CPU 독점 : 타임 슬라이스가 끝나기 전 아무 파일을 대상으로 I/O request를 보내게 해 CPU를 양도하며 계속 높은 우선순위 큐에 머무르며 CPU를 독점.
  - 프로그램의 특성을 동적으로 반영할 수 없음(CPU 위주 작업의 처리에서 interactive한 작업으로 또는 그 반대로의 전환이 어려움).

---

## 8.3 시도 2 : 우선순위의 상향 조정

이를 개선하기 위해 주기적으로 모든 작업의 우선순위를 상향 조정(boost)하여 CPU 위주의 작업(긴 실행 시간을 요구하는 작업)이 진행되도록 보장한다( **<규칙 5> : 일정 시간 S가 지나면, 시스템의 모든 작업을 최상위 큐로 이동시킨다.** ).

![img4](https://user-images.githubusercontent.com/35681772/59988920-cdd3df80-9677-11e9-92b6-53f7eec377e9.png)

이렇게 하면 starvation이 발생하지 않는다는 것을 보장받을 수 있고, CPU 위주의 작업이 interactive형 작업으로 그 특성이 변할 경우 우선순위 상향을 통해 스케줄러가 그에 적절한 스케줄링 방법을 적용할 수 있게 된다.

![image15](https://user-images.githubusercontent.com/35681772/59988926-d5938400-9677-11e9-90f4-0592458c09ab.jpg)

이 예제에서는 하나의 긴 실행 시간의 작업과 두개의 interactive형 작업이 존재한다.

좌측의 경우 우선순위 상향이 없어 두개의 짧은 작업들이 도착한 후 긴 실행 시간의 작업에 starvation이 발생한다.

우측의 경우 50msec마다 우선순위 상향이 일어나고 있으므로 긴 실행 시간의 작업도 꾸준히 실행되는 것을 보장받게 된다.

이때 '일정 시간 S'가 너무 크면 CPU 위주의 작업의 starvation이 발생, 너무 작으면 interactive형 작업이 CPU를 적정시간동안 사용할 수 없음 : *부두 상수(voo-doo constants)*

---

## 8.4 시도 3 : 더 나은 시간 측정
CPU 독점의 문제가 발생할 수 있는 이유는 **<규칙 4a>** 와 **<규칙 4b>** 때문인데 이를 해결하고자 **MLFQ의 각 단계에서 CPU 총 사용 시간을 측정한다**.

스케줄러는 현재 단계에서 프로세스가 소진한 CPU 사용 시간을 저장하고, 타임 슬라이스를 한 번에 소진하든 짧게 여러 번 소진하든 상관 없이 해당된 시간을 모두 소진하면 다음 우선순위 큐로 강등된다.

**이를 가능케 하고자 규칙 4a와 4b를 합쳐 하나로 재 정의한다.**

![image16](https://user-images.githubusercontent.com/35681772/59988930-ddebbf00-9677-11e9-861a-be68dda03579.jpg)

![img1](https://user-images.githubusercontent.com/35681772/59988940-e9d78100-9677-11e9-8926-9cf1efb2e5f2.jpg)

좌측의 경우 기존 <규칙 4a>와 <규칙 4b>가 적용되었을 때의 스케줄링을 보여준다. 하지만 새로 정의된 <규칙 4>를 적용시킨 우측의 경우 프로세스의 I/O와 무관하게 우선순위가 하향조정되어 CPU를 자기 몫 이상으로 사용할 수 없게 된다.

---

## 8.5 MLFQ 튜닝과 다른 쟁점들

그렇다면 필요한 변수들을 스케줄러가 어떻게 설정할지, 몇 개의 큐가 존재해야 하는지, 큐당 타임 슬라이스의 크기는 어느정도가 적절한지? 에 대한 이슈가 남는다.

큐당 타임 슬라이스의 크기 : MLFQ 기법들은 큐 별로 타임 슬라이스를 변경할 수 있다. 우선순위가 높은 큐는 보통 짧은 타임 슬라이스가 주어짐.

![image18](https://user-images.githubusercontent.com/35681772/59988950-f8be3380-9677-11e9-8624-59412fd0b7c2.jpg)

  - 여기서 가장 높은 우선순위 큐는 10ms, 중간 큐는 20ms, 가장 낮은 큐는 40ms 의 타임 슬라이스를 갖는다.
  - 또는 CPU 사용이 시간이 지남에 따라 감쇠(decay)되어 우선순위 상향을 제공하는 경우도 있음(감쇠-사용, decay-usage 알고리즘).
  - 그 외 스케줄러는 OS의 작업을 위해 일부 가장 높은 우선순위를 남겨두는 기능도 제공.

## 8.6 MLFQ : 요약 

멀티 레벨 피드백 큐는 *멀티 레벨 큐* 를 가지고 있으며, 지정된 작업의 우선순위를 정하기 위하여 *피드백* 을 사용한다.

![image19](https://user-images.githubusercontent.com/35681772/59988962-02e03200-9678-11e9-992e-d234641e2369.jpg)

  - MLFQ는 작업의 특성에 대한 정보 없이, 작업의 실행을 관찰한 후 그에 따라 우선순위를 지정한다.
  - MLFQ는 소요시간(turnaround time)과 응답시간(response time)을 모두 최적화한다. 
  - 짧게 실행되는 interactive형 작업의 경우 우수한 성능을 제공, 오래 실행되는 CPU 집중 작업에 대해서는 공정하게 실행되게 하여 starvation을 방지.

  ---