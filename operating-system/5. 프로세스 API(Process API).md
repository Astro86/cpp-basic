
# 5\. 프로세스 API(Process API)

## 5.1 fork() 시스템 콜

서버 프로그램은 TCP 소켓을 계속 대기중인 상태로 둔 프로그램이다. request가 들어오면 시스템 입장에선 fork()를 통해 자식 프로세스를 생성하여 request를 처리하는 방식이다.


![fork](https://user-images.githubusercontent.com/35681772/59988485-2a35ff80-9676-11e9-8c5f-fa75bd67464b.jpg)

  - fork() 시스템 콜은 프로세스를 생성할 때 사용한다. 
  - 위 예시에선 **PID(프로세스 식별자(Process Identifier))** 를 출력하고 있는데, PID는 프로세스의 실행이나 중단과 같이 특정 프로세스를 대상으로 작업을 해야 할 경우 *프로세스를 지칭 또는 식별하기 위해 사용* 된다. 
  - fork() 시스템 콜이 호출된 이후부터 호출한 프로세스(부모)의 복사본(자식)이 생성된다. 이 때의 자식 프로세스는 부모 프로세스의 호출 스택이나 변수 등의 메모리 사용 내역도 모두 복사하여 새로운 주소 공간, 레지스터, PC값을 가지며 생성된다. 
  - *fork() 시스템 콜의 반환 값이 서로 다르므로* 부모 프로세스와 자식 프로세스를 구별할 수 있다. **부모 프로세스는 생성된 자식 프로세스의 PID를 반환받고, 자식 프로세스는 0을 반환받는다.** 
  - 이 둘중 누가 먼저 처리될 지는 CPU 스케줄러(Scheduler)에 의해 결정되므로 어느 프로세스가 먼저 실행된다고 단정하기 어렵다.

---

## 5.2 wait() 시스템 콜

![wait](https://user-images.githubusercontent.com/35681772/59988495-34f09480-9676-11e9-96ad-b2e494462ad3.jpg)

  - 위 예제에서 부모 프로세스는 wait() 시스템 콜을 호출하여 자식 프로세스의 종료 시점까지 자신의 실행을 잠시 중지시킨다.
  - 스케줄러에 의해 랜덤하게 먼저 실행된 프로세스가 부모일지라도 wait()을 요청하여 자식이 먼저 실행되고 부모가 실행되는 구조이다.

---

## 5.3 exec() 시스템 콜

자식 프로세스에서 exec() 호출시 전혀 다른 프로세스를 실행시킬 수 있다.

![exec](https://user-images.githubusercontent.com/35681772/59988511-4174ed00-9676-11e9-9883-9a3d729338c0.jpg)

![img4](https://user-images.githubusercontent.com/35681772/59988524-4c2f8200-9676-11e9-80dd-1d8760927684.png)

  - exec() 시스템 콜은 자기 자신이 아닌 다른 프로그램을 실행해야 할 때 사용. 즉, 자신의 복사본이 아닌 다른 프로그램을 실행해야 할 경우 사용한다.
  - exec() 시스템 콜은 호출이 되면 인자의 내용(ex. 실행파일 : wc, 실행파일의 인자 : p3.c)을 토대로 해당 실행 파일의 코드와 정적 데이터를 읽어 들여 *현재 실행 중인 프로세스의 코드 세그먼트와 정적 데이터 부분을 덮어 쓴다.* 힙과 스택 및 주소 공간들이 새로운 프로그램의 실행을 위해 다시 초기화된다.
  - 새로운 프로세스를 생성하지는 않고, 현재 실행 중인 프로그램(p3)을 다른 프로그램(wc)로 대체하는 것이다.
  - fork()를 하게되면 부모의 메모리가 자식 프로세스로 memcpy가 이루어지게 되는데, exec()를 사용하면 wc라는 새로운 프로그램으로 over-write 하게 된다.

---

## 5.4 왜 이런 API를?
UNIX의 쉘을 구현하기 위해서는 fork()와 exec()을 분리해야 한다. 그래야만 쉘이 fork()를 호출하고 exec()를 호출하기 전에 다른 코드를 실행할 수 있기 때문이다. 대부분의 경우 쉘은 파일 시스템에서 실행 파일의 위치를 찾고 명령어를 실행하기 위하여 fork()를 호출하여 새로운 자식 프로세스를 만들고, 그 자식 프로세스로 exec()를 호출하여 프로그램을 실행시킨 후 wait()을 호출하여 명령어가 끝나기를 기다리는 식이다. 이렇게 하여 fork() / exec() 조합이 프로세스를 생성하고 조작하는 강력한 방법이 된다.

---
## 5.5 여타 API들 및 요약

UNIX 시스템에는 fork(), exec() 및 wait() 외 여러 프로세스 관련 인터페이스가 있다. 그 중 몇가지 예를들면 kill() 시스템 콜은 프로세스에게 시그널(signal)을 보내는데 사용된다.
시그널(signal)은 프로세스를 중단(block) 또는 삭제하는 등의 작업을 수행한다. 시그널은 외부 사건을 프로세스에게 전달하는 수단이 된다. 그 외 여러 명령어들이 있으나 운영체제 과목에서 다루는 범위를 벗어남. 

---