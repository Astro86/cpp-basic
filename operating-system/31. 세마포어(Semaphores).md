# 31. 세마포어 (Semaphores)

세마포어는 다양한 동기화 관련 문제(락, 컨디션 변수 등)를 한 번에 해결하는 방법을 찾아내고자 다익스트라(Edsger Dijkstra) 와 그의 동료들이 발견해 낸 동기화 기법이다.

이번에 다뤄볼 내용은 다음과 같다.

  - 세마포어의 정의
  - 락과 컨디션 변수 대신에 세마포어를 사용하는 방법
  - 락과 컨디션 변수를 사용하여 세마포어를 만드는 것이 가능한지 여부
  - 세마포어를 사용하여 락과 컨디션 변수를 만드는 것이 가능한지 여부

---

## 31.1 세마포어 : 정의 (Semaphores : A Definition)

**세마포어는 정수 값을 갖는 객체** 로서 다음 두 개의 루틴으로 조작할 수 있다. 

POSIX 표준에서의 세마포어 루틴 두 가지
  - sem_wait()
  - sem_post()

세마포어는 초기값에 의해 동작이 결정된다. 따라서 **반드시 초기화가 선행** 되어야 한다.

![img1](https://user-images.githubusercontent.com/35681772/59991598-ff9e7380-9682-11e9-9a0d-97a35a22e604.png)

위의 예시에서 _세마포어 s를 선언 후, init()에 3번째 인자로 1을 전달하여 세마포어 값을 1로 초기화한다. 2번째 인자는 0으로 주는데, 같은 프로세스 내의 쓰레드 간에 세마포어를 공유하겠다는 것을 의미한다._

![img2](https://user-images.githubusercontent.com/35681772/59991608-062ceb00-9683-11e9-8bed-a5f78991eea0.png)

init() 후에 sem_wait(), sem_post() 함수를 호출하여 세마포어를 다루면 된다. 이 루틴들은 멀티 쓰레드 상황 하에 다수의 동시호출을 가정하고 사용된다. 

_sem_wait() 과 sem_post() 함수의 성질은 다음과 같다._
  1) sem_wait() 함수는 세마포어의 값이 0 이상이면 즉시 리턴한다. **세마포어의 값이 음수인 경우, 0 이상이 될 때까지 호출자를 대기시킨다.** 다수의 쓰레드들이 sem_wait()을 호출할 수 있어 대기큐에는 다수의 쓰레드가 존재할 수 있다. 쓰레드들은 spin 또는 sleep으로 대기하게 된다.

  2) sem_post() 함수는 세마포어 값을 증가시키고 대기 중인 쓰레드 중 하나를 깨운다. wait() 처럼 특정 조건이 될 때까지 호출자를 대기시키거나 하지 않는다.

  3) 세마포어가 음수라면 그 값은 현재 대기 중인 쓰레드의 개수를 나타낸다. 일반적으로 이 값을 확인할 수는 없지만, 이 성질을 알아두는 것이 세마포어 작동 원리를 이해하는데 도움이 된다.

  4) 또한 이 두 함수는 원자적(atomic)으로 실행된다고 가정한다. 세마포어 루틴 내에서의 race condition이 발생하는 것을 해결하기 위해 락과 컨디션 변수를 사용하게 된다.

---

## 31.2 이진 세마포어(락) (Binary Semaphores (Locks))

가장 먼저 '락'에 세마포어를 적용해보자. 

![img1](https://user-images.githubusercontent.com/35681772/59991616-0c22cc00-9683-11e9-84d0-79fa2bead738.jpg)

sem_wait() 과 sem_post() 쌍으로 critical section 부분을 둘러 싸서 구현한다. 여기서 init()의 초기값 X는 1로 설정이 되어야 한다.

![img3](https://user-images.githubusercontent.com/35681772/59991628-1349da00-9683-11e9-9a5a-edfc9be5e3d3.png)

위 그림은 두 개의 쓰레드가 존재하지만, 하나의 쓰레드만 세마포어를 사용하는 예시이다.

쓰레드 T0이 sem_wait()을 호출하면 세마포어 값을 1 감소시켜 0으로 만든다. 쓰레드는 세마포어 값이 음수인 경우에만 대기한다. 따라서 세마포어의 값이 0이므로 곧장 리턴하여 critical section에 진입하게 된다. 그 후 sem_post()를 호출하여 세마포어 값이 다시 1이 되고, 대기 중인 쓰레드가 없으므로 아무도 깨우지 않고 종료된다.

![img4](https://user-images.githubusercontent.com/35681772/59991634-1c3aab80-9683-11e9-980e-7f0548e42b16.png)

위 그림은 쓰레드 T0이 '락을 보유하고 있을 때(sem_wait()을 호출하여 critical section내에 진입했고 sem_post()를 호출하지는 않은 상황)' 다른 쓰레드 T1이 sem_wait()을 호출하여 critical section에 진입을 시도하는 상황의 시나리오다.

이 경우 쓰레드 T1은 세마포어 값을 -1로 감소시키고 대기에 들어가게 된다(프로세서를 내어주고 스스로 sleep에 들어간다). 그래서 쓰레드 T0이 다시 실행되면 sem_post()를 호출하여 세마포어 값을 0으로 증가시키고, 잠자던 쓰레드 T1을 깨운다. 깨어난 쓰레드 T1은 락을 획득하여 critical section에 진입하고 작업이 모두 끝나면 세마포어 값을 다시 1로 증가시키며 종료된다.

여기서 쓰레드의 상태는 실행, 준비, 대기 3가지로 나타나 있다. 실행은 말 그대로 CPU를 보유하고 있는 상태이다. 준비는 실행할 수 있지만 아직 실행되지는 않은 즉, CPU를 받을 수 있는 상태이다. 대기는 sleep 또는 spin으로 구현할 수 있으며, sleep 상태에서는 CPU를 받을 수 없다(스케줄링 되지 않는다).

이렇게 _세마포어를 락으로 사용하는 것을 **이진 세마포어(binary semaphore)**_ 라고 부른다. 락은 사용 가능, 사용 중 이렇게 두 개의 상태만을 갖기 때문이다.

---

## 31.3 컨디션 변수로서의 세마포어

컨디션 변수는 어떤 조건이 참이 되기를 기다리기 위해 특정 쓰레드를 멈출 때 사용된다. 세마포어를 컨디션 변수처럼 사용할 수 있다.

가령, 리스트에서 객체를 삭제하기 위해 리스트에 객체가 추가되기를 대기하는 쓰레드가 있을 수 있다. 이런 경우 전형적으로 _'하나의 쓰레드가 어떤 사건의 발생을 기다리고, 또 다른 쓰레드는 해당 사건을 발생시킨 후, 시그널을 보내 기다리는 쓰레드를 깨우는'_ 패턴으로 구현될 수 있다. 

![img5](https://user-images.githubusercontent.com/35681772/59991641-2492e680-9683-11e9-8295-7ced5a217f6b.png)

위 그림에서 처럼, 부모 프로세스는 자식 프로세스 생성 후 sem_wait() 을 호출하여 자식 프로세스를 대기할 수 있다. 자식 프로세스에서는 sem_post()를 호출하여 대기중인 부모 프로세스를 깨울 수 있다.

여기서 관건은 **'세마포어 값을 무엇으로 설정하는가?'** 이다. 위 코드에서 세마포어 값인 X는 0으로 초기화 되어야 한다. **세마포어 값이 음수인 경우 호출자를 대기시키므로** 0으로 초기화를 해 두면, 아래 두 시나리오 모두 적절한 대응이 가능하다.

![img8](https://user-images.githubusercontent.com/35681772/59991647-29f03100-9683-11e9-973d-b55472773389.png)

먼저 부모 쓰레드에서 자식 쓰레드 생성 이후 부모 쓰레드가 계속 실행되는 경우, 부모는 sem_wait()이 호출되며 세마포어 값을 -1로 낮추고 대기 상태로 들어가게 된다(세마포어 값이 음수일 때, 호출자를 대기시킴). 이어서 자식 쓰레드가 실행되며 작업 완료 후 sem_post()로 다시 세마포어 값을 0으로 증가시킨 후, 부모 쓰레드를 깨우게 된다. 깨어난 부모 쓰레드는 세마포어 값이 0이므로 리턴되어 프로그램을 종료한다.

다른 시나리오로 부모 쓰레드에서 자식 쓰레드 생성 이후 자식 쓰레드가 곧장 실행되는 경우, 자식 쓰레드에서 작업 후 sem_post()를 실행하여 세마포어 값을 1로 증가시키고 대기중인 쓰레드를 깨우려 하지만, 대기중인 쓰레드가 없으므로 곧장 종료된다. 그리고 부모 쓰레드로 오게 되면 sem_wait()을 실행하여 세마포어 값을 1에서 0으로 감소 시켜도 음수가 아니므로 대기 없이 곧장 리턴되어 메인함수가 종료된다.

---

## 31.4 생산자/소비자(유한 버퍼) 문제 (The Producer/Consumer (Bounded Buffer) Problem)

생산자/소비자 문제에서도 세마포어를 적용하여 해결할 수 있다.

---

### 첫 번째 시도 (First Attempt)

![img9](https://user-images.githubusercontent.com/35681772/59991652-32e10280-9683-11e9-8c8a-c2dcfca27a0b.png)

![img10](https://user-images.githubusercontent.com/35681772/59991660-38d6e380-9683-11e9-80ba-f0d5a6d8a817.png)

위와 같이 P/C를 구현하였을 때의 문제점을 알아보자. 먼저 MAX = 1 이고 생산자와 소비자 쓰레드가 각각 하나씩 있으며 CPU도 하나인 상황에서의 시나리오를 다뤄본다.

empty 와 full 이라는 두 개의 세마포어를 사용하여 구현을 시도하였다. 쓰레드는 이 두 개의 세마포어를 이용하여 공유 버퍼가 비었는지 가득 찼는지를 확인한다. 

소비자 쓰레드가 먼저 실행 된 경우, C1 라인에 도달하여 sem_wait(&full)을 호출하게 된다. 세마포어 full 은 0으로 초기화 되어있기 때문에 wait()을 호출한 소비자 쓰레드는 세마포어 full을 -1로 만들고 잠들게 된다.

그 후, 생산자 쓰레드가 실행되어 P1 라인에 도달하여 sem_wait(&empty)를 호출하게 된다. 세마포어 empty 는 MAX로 초기화 되어있기 때문에 MAX = 1을 가진다. 따라서 세마포어 empty를 0으로 낮추고 곧장 리턴되어 put()함수를 통해(P2 라인) 공유 버퍼에 값을 집어 넣는다. 그리고 sem_post(&full) 을 호출하여 세마포어 full을 0으로 만들고 대기 상태의 소비자 쓰레드를 깨운다(대기 → 준비).

그 후로의 전개는 별 에러 없이 잘 작동하게 된다.

하지만, MAX = 10 이고 멀티 쓰레드 상황에서의 시나리오를 다뤄보자.

mutex를 사용하지 않아 경쟁 조건이 발생하게 된다. 두 개의 생산자 쓰레드 Pa와 Pb 가 put()을 거의 동시에 호출 한 경우, Pa가 먼저 실행되어 버퍼에 값을 넣고(f1 라인) fill 값을 갱신(f2 라인)하기 전에 context switch가 일어나는 경우 생산자 쓰레드 Pb에서 Pa가 값을 쓴 동일한 fill 인덱스에 value를 덮어 쓰게 된다. 따라서 critical section에 대한 mutual exclusion이 보장되지 않는 문제가 발생하게 된다.

---

### 해답 : 상호 배제의 추가 (A Solution: Adding Mutual Exclusion)

버퍼에 값을 넣고 버퍼의 인덱스를 증가시키는 동작은 critical section이기 때문에 락으로 감싸줘야 한다.

![img2](https://user-images.githubusercontent.com/35681772/59991669-40968800-9683-11e9-8fba-49e851eca09d.jpg)

위 <그림 31.11> 과 같이 critical section에 mutual exclusion을 부여한 경우를 보자. 이 경우 잘못 mutual exclusion이 부여되었는데, 이 또한 잘못되었다. 잘못된 시나리오는 다음과 같다.

소비자가 먼저 실행되는 경우 wait(&mutex)에서 세마포어 mutex(락)를 0으로 만들고 락을 획득한다(c0 라인). 이어서 세마포어 full에 대해 wait()을 호출한다(c1 라인). 세마포어 full 값이 -1이 되어 호출한 소비자 쓰레드는 대기상태로 들어가게 된다. **여기서 중요한 점은 대기상태로 들어간 소비자 쓰레드가 락을 가진 상태로 대기상태에 들어갔다는 점이다.**

그 후, 생산자가 실행되어 세마포어 mutex(락)에 대해서 `wait(&mutex)` 을 실행하는데(c0 라인), 세마포어 mutex(락)는 -1이 되어 생산자 쓰레드를 sleep 모드로 들어가게 한다. 생산자와 소비자 모두 대기상태로 들어가 **교착 상태(Deadlock)** 가 발생하게 된다.

### 최종, 제대로 된 해법 (At Last, A Working Solution)

이 문제를 해결하기 위해선 락의 범위(scope)를 줄여 재설정 해야 한다. 

![img3](https://user-images.githubusercontent.com/35681772/59991674-468c6900-9683-11e9-96c5-b4dd990a3ad6.jpg)

위 <그림 31.12>와 같이 락의 범위를 줄여 mutex(락)를 획득하고 해제하는 코드를 critical section 바로 위 아래로 감쌌다.

이렇게 해야 정상적으로 작동하는 유한 버퍼(공유 버퍼)가 된다.

---

## 31.5 Reader-Writer 락 (Reader-Writer Locks)

락을 한 단계 개선하여 사용하는 방법이다. 특정 리스트에 삽입과 검색을 하는 연산이 수행되는 알고리즘에서 삽입은 락으로 감싸서 해당 critical section에는 하나의 쓰레드만 들어와야 한다. 하지만 검색의 경우 값의 변경이 없어 여러 쓰레드가 동시에 접근하여도 된다. 핵심 개념은 **writer 쓰레드가 값을 쓰고(write) 있는 경우 reader 쓰레드는 공유 변수에 접근할 수 있지만, reader 쓰레드가 값을 읽고 있는 경우 writer 쓰레드는 공유 변수에 접근할 수 없어야 한다.**

![img4](https://user-images.githubusercontent.com/35681772/59991683-4db37700-9683-11e9-97c7-524b64332156.jpg)

자료 구조를 '갱신(write)'하려면 새로운 동기화 연산 쌍을 사용한다. 갱신에 필요한 락은 `rwlock_acquire_writelock()` 과 `rwlock_release_writelock()` 이 된다. _세마포어 writelock_ 은 하나의 writer 쓰레드만이 락을 획득할 수 있도록 한다.

자료 구조를 '읽는(read)'경우 세마포어 lock을 획득하고, 현재 reader 쓰레드의 개수를 나타내는 readers의 수를 늘린다. 여기서 중요한 점은 **읽기 락 획득시 세마포어 writelock에 대해서도 `sem_wait(&rw->writelock)` 을 통해 쓰기 락을 같이 획득한다.**

이렇게 되면 _모든 reader 쓰레드들이 읽는 과정을 끝낼 때까지 writer 쓰레드는 대기하여야 한다._ critical section을 빠져나오는 마지막 reader 쓰레드가 'writelock'에 대한 sem_post()를 호출하여야만 대기 중인 writer 쓰레드가 락을 획득할 수 있다.

이 방법은 잘 작동하지만 다음과 같은 단점을 지니고 있다.

  - 공정성 문제 : 쓰기 쓰레드에게 기아 현상(starvation)이 발생하기 쉽다. 
  - 성능 문제 : 복잡하게 구현할 수록 오버헤드가 훨씬 더 커지게 된다.

따라서 단순하고 빠른 락이 더 나은 선택이 될 수 있다.

---

## 31.6 식사하는 철학자 (The Dining Philosophers)

![img12](https://user-images.githubusercontent.com/35681772/59991692-54da8500-9683-11e9-8c70-c72ea9f51084.png)

'다익스트라' 가 제기한 Dining Philosopher라는 문제는 다음과 같다.

다섯 명의 '철학자'가 식탁 주위를 둘러 앉아있고, 총 다섯 개의 포크가 철학자와 철학자 사이 놓여있다. 철학자는 식사할 때와 생각할 때가 있다. 그리고 철학자는 식사를 할 때 자신의 왼쪽, 오른쪽의 포크 두개를 사용하여야 식사가 가능하다.

![img13](https://user-images.githubusercontent.com/35681772/59991696-5a37cf80-9683-11e9-81e3-6b8ba269d946.png)

위 그림은 철학자의 기본 동작을 나타내는 반복문이다.

고려해야 될 핵심 쟁점은 `getfork()`와 `putfork()`의 루틴을 작성하되, 교착 상태의 발생을 방지해야 하고, 어떤 철학자도 식사를 하지 못해 굶주려서는 안된다. 또한 병행성이 높아야 한다(가능한 많은 철학자가 동시에 식사를 할 수 있어야 한다).

---

### 불완전한 해답 (Broken Solution)

![img14](https://user-images.githubusercontent.com/35681772/59991700-5f951a00-9683-11e9-9db1-b799468abc7e.png)

Dining Philosopher를 구현하기 위해 제시된 한가지 방법이다. 포크가 필요할 때 단순하게 하나의 락을 획득하는 방식이다. 먼저 왼쪽 락을 획득하고 오른쪽 락을 이후에 획득하는 방식인데, 문제는 위 처럼 구현하게 되면 교착 상태에 빠지게 된다. 

모든 철학자들이 동시에 왼쪽 락을 획득하게 된 경우, 오른쪽 락을 획득하려 시도하지만 그 오른쪽 락은 다른 철학자의 왼쪽 락에 해당되어 대기 상태에 들어가게 된다. 모든 철학자가 대기하게 되는 상황이 일어나는 것이다.

---

### 해답 : 의존성 제거 (A Solution: Breaking The Dependency)

![img15](https://user-images.githubusercontent.com/35681772/59991709-6459ce00-9683-11e9-97b5-4eec5cb37cda.png)

이 문제는 _최소한 하나의 철학자가 다른 순서로 포크를 집도록 하면 된다._ 위 예시에서는 철학자 4(p4)가 다른 철학자들과는 다른 순서로 포크를 집을 수 있도록 구현하여, 각 철학자가 하나의 포크를 든 채로 다른 포크를 대기하는 상황은 발생하지 않는다.

---

## 31.7 세마포어 구현 (How To Implement Semaphores)

low-level 동기화 기법인 락과 컨디션 변수를 사용하여 세마포어를 구현하면 다음과 같다. 여기선 Zemaphore라는 이름을 사용하였다.

![img16](https://user-images.githubusercontent.com/35681772/59991713-691e8200-9683-11e9-8738-603787b8b53b.png)

다익스트라가 정의한 세마포어와의 차이점은 **'세마포어의 음수 값이 대기 중인 쓰레드의 수를 나타낸다'** 이다. 위의 제마포어에서는 값이 0보다 작아지지 않는다. 이 방식이 구현하기 쉬울 뿐더러 Linux에 구현된 방식이다.


---

## 31.8 요약 (Summary)

세마포어는 병행 프로그램 작성을 위한 강력한 기법이다. 간단하고 유용하여 세마포어 만으로도 락과 컨디션 변수를 대체하기도 한다.

---
