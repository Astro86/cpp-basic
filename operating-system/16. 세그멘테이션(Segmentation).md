# 16. 세그멘테이션(Segmentation)

베이스/바운드 레지스터 방식은 아래와 같은 단점을 지님.

  - 메모리 낭비가 심하다 : 스택과 힙 사이에 사용되지 않는 큰 공간이 존재하게 되고, 이 공간은 사용되지 않더라도 물리 메모리를 차지하게 됨.
  - 유연성이 없다 : 요청된 주소 공간이 물리 메모리보다 큰 경우 실행이 어렵다.

이러한 문제점을 해결하고자 나온 아이디어가 바로 **"세그멘테이션(Segmentation)"**

---

## 16.1 세그멘테이션 : 베이스/바운드(base/bound)의 일반화

**세그멘트(Segment)** : 특정 길이를 가지는 연속적인 주소 공간. 코드, 스택, 힙 세종류의 세그멘트가 있다. 이 세그멘트 마다 베이스와 바운드 쌍을 둬서 각 세그멘트를 물리 메모리의 각기 다른 위치에 배치하여 사용되지 않는 공간이 물리 메모리를 차지하는 것을 방지한다.

![img2](https://user-images.githubusercontent.com/35681772/59990030-9156b280-967c-11e9-945e-c3dc4dfde905.png)

가상주소 100 코드 세그멘트의 경우 100은 2KB(Bound 값)내에 있으므로, Offset 값에 베이스 값을 더해 100 + 32KB = 32868이라는 물리 메모리 주소를 얻을 수 있다.

가상주소 4200 힙 세그멘트의 경우 Offset 4200을 베이스 값에 더하는게 아니라, 
4200을 힙 세그먼트의 시작점에서 뺀 값을 구한다. 즉, (4200 - 4KB) + 34KB = (4200 - 4096) + 34KB = 34920이라는 물리 메모리 주소를 얻을 수 있다.

잘못된 주소를 접근하려는 경우(힙의 마지막을 벗어난 7KB와 같이) 하드웨어가 그 주소가 범위를 벗어났다는 것을 감지하고 운영체제에 트랩을 발생시켜 운영체제는 프로세스를 종료시킨다. **(= 세그멘트 위반(Segment violation) 또는 세그멘트 폴트(Segment Fault))**

---

## 16.2 세그먼트 레지스터(Segment Register) : 어떤 세그먼트를 참조하는지 알기위해선

하드웨어는 변환(Translation)을 위해 세그먼트 레지스터를 사용하는데 아래와 같다.

![img3](https://user-images.githubusercontent.com/35681772/59990039-99aeed80-967c-11e9-9915-c933cdd49551.png)

최상위 비트 중 몇개를 사용하여 특정 세그먼트를 가르키도록 할당한다.

예시에서는 최상위 2비트(01)가 하드웨어에게 참조하는 세그먼트의 종류를 알려주게 된다. 여기서 01은 힙 세그먼트를 가르키고 따라서 가상주소에 더해야하는 베이스 값과 그 바운드 값의 참조가 쉬워져 앞서 했던 (가상주소 - 그 세그먼트 시작주소)와 같은 연산이 불필요해짐.

---

## 16.3 Stack

스택의 경우 다른 세그먼트들과는 달리 반대 방향으로 확장된다. 그러므로 조금 다른 계산법이 필요하다. 먼저 추가적인 하드웨어를 둬서 이 세그먼트가 어느 방향으로 확장하는지를 알려주도록 한다.

![img5](https://user-images.githubusercontent.com/35681772/59990046-9fa4ce80-967c-11e9-9854-6e2e1d6f6327.png)

가상주소 15KB는 물리주소 27KB에 매핑된다. 이를 구하는 과정을 알아보면, 가상주소 15KB를 이진수(11 1100 0000 0000) 형태로 바꿔 최상위 2비트(11)을 제외하면 3KB의 Offset이 남게된다. 스택의 경우 반대 방향으로 확장되므로, 음수 Offset을 얻기위해 그 Offset에서 세그먼트 최대 크기(4KB, 모든 offset bit이 1일 때)를 빼 -1KB라는 값을 얻고 이를 스택 베이스 값에 더해 27KB라는 물리주소 값을 얻어낸다. 이 떄 바운드값은 음수 Offset의 절대값과 계산된다.

---

## 16.4 Support for Sharing

![img6](https://user-images.githubusercontent.com/35681772/59990051-a5021900-967c-11e9-9138-cf045502b36d.png)

메모리를 절약하기 위해 주소공간들 간에 특정 메모리 세그먼트를 공유한다. 메모리 세그먼트를 공유하기위해 필요한 옵션이 **"protection"** 이다. 해당 세그먼트를 읽기/쓰기가 모두 가능한지, 읽기 전용인지를 구분하기위해 protection bit을 추가로 둔다. 주로 코드 세그먼트를 공유하는것이 일반적이며, 읽기 전용으로 설정하여 주소 공간의 독립성을 유지하며 공유가 가능한 형태로 만들어준다.

사용자 프로세스가 읽기 전용 세그먼트에 쓰기를 시도하는 경우 하드웨어는 예외를 발생시켜 운영체제가 그 프로세스를 처리하도록 알려준다.

---

## 16.5 Fine-grained(소단위) vs. Coarse-grained(대단위) Segmentation

앞서 살펴본 세그먼트들은 큰 크기의 주소공간으로 분할된 코드, 스택, 힙만을 다뤘으나 일부 초기 시스템에서는 더 작은 크기의 소단위 세그먼트들을 사용하기도 하였다.

---

## 16.6 운영체제의 지원

세그먼트 단위로 주소공간을 할당하게 됨으로써 스택과 힙 사이의 사용하지 않는 공간을 줄일 수 있게되어 같은 크기의 물리 메모리에 더 많은 주소공간을 할당할 수 있게 되었다.

![img7](https://user-images.githubusercontent.com/35681772/59990060-acc1bd80-967c-11e9-9e75-57d499131ed5.png)

그러나 세그먼테이션에는 다음과 같은 문제점들이 존재하게 된다.

- Context Switching 발생시 운영체제는 어떤일을 해야할지? : 세그먼트 레지스터의 저장 및 복원
- 미사용 중인 물리 메모리 공간을 어떻게 관리할지?( **External fragmentation** 문제) :

  - 이 문제는 작은 크기의 빈 공간들로 채워져서 **이러한 작은 빈 공간들엔 새로운 세그먼트들을 할당하기 어려워 지는 경우** 를 말한다.
  - 이를 해결하기위해 압축(위 사진)을 하는 방법이 있으나 압축은 비용이 많이든다(큰 메모리 부하, 긴 프로세서 시간).
  - 따라서 빈 공간 리스트를 관리하는 알고리즘(최적 적합(best-fit), 최악 적합(worst-fit), 최초 적합(first-fit), 버디 알고리즘(buddy algorithm)) 등을 사용하게 됨. 하지만 어느 알고리즘을 사용하여도 External fragmentation 문제는 존재하게 됨.
  - 최적 적합 알고리즘 : 빈 공간 리스트에서 요청된 크기와 가장 비슷한 크기의 공간을 할당.

---

## 16.7 요약
세그먼테이션은 공간에 대한 낭비를 피함으로써 메모리 가상화를 효과적으로 실현시키는 방법이 됨. 그러나 세그먼트들의 크기가 일정하지 않기 때문에 **External fragmentation** 문제가 발생하게되고, 또한 잘 사용되지 않는 힙의 경우도 물리 메모리내에 존재하게 되어 사용여부와 관계없이 메모리를 차지하게 되는 문제( **유연성(flexibility)** )가 발생한다. 이 문제점들을 해결하는 방법들을 알아보자.

---