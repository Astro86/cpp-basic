# 13. 주소공간(Address Spaces)

메모리 가상화를 통해 프로그래머가 메모리를 별로 신경쓰며 프로그램을 만들지 않아도 되게 되었다 : OS가 handle 해주므로. 실제로는 linear한 공간이 할당된 게 아닌데 이걸 OS와 Hardware가 우리에게 illusion을 주고있다는 것.

Benefit of Memory Virtualization?
  - Ease of use in programming : 개발자들이 메모리 공간을 크게 신경쓰지 않고 프로그래밍을 가능하게 함
  - Memory efficiency in terms of times and space : OS가 중앙 집중적으로 관리하므로 공평하고 효율적이다
  - The guarantee of isolation for processes as well as OS : 메모리에 여러 프로세스가 동시에 실행중인 경우 어짜피 메모리라는게 읽을 수 있는 것이기에, 다른 메모리 공간을 읽어버린다면? 개인정보나 Key 값들을 읽어갈 수 있다. 따라서 남의 프로세스를 읽거나 참조하는것을 불가능하게 하고자 Process isolation이 필요하다. 또 특히 OS는 privilige가 높으므로 OS를 보호해야 한다. 그래서 OS는 Security의 issue를 항상 가지고 있다.

결과적으로 프로세스가 접근하는 메모리에 대해 자기 자신도 어디에 실제 존재하는지 모르는 상황을 준다는 것(Virtual address로만 접근하고 Physical address는 어디인지 모른다 그리고 그래도 작업을 해 나가는데 전혀 지장이 없게끔 한다는 것)

## 13.1 초기 시스템
 
 초기 사용자는 운영체제로부터 그리 많은 것을 기대하지 않음. 가상화의 개념 또한 거의 존재하지 않았고, 운영체제는 메모리에 상주하는 라이브러리의 집합일 뿐이었음.

---

 ## 13.2 멀티프로그래밍과 Time-Sharing
멀티프로그래밍의 시대가 도래하며, CPU의 이용률이 증가되어 효율성이 개선됨. 많은 사용자가 동시에 컴퓨터를 사용하고, 현재 실행 중인 작업으로부터 즉시 응답을 원하기 때문에 대화식(interactivity) 사용의 개념이 중요해짐.

초기에 구현한 Time-Sharing의 방법으로는 하나의 프로세스를 짧은 시간 동안 실행시키는데, 프로세스가 도중에 중단되면 중단 시점의 모든 상태를 디스크와 같은 저장 공간에 저장하고 다른 프로세스의 상태를 탑재하는 방식으로 구현됨. 그러나 이런 방식은 너무 느려 문제가 됨.

따라서 프로세스 전환시 프로세스를 메모리에 그대로 유지하면서, 운영체제가 Time-Sharing을 효율적으로 구현할 수 있는 방법으로, OS가 하나의 프로세스(A)에게 CPU를 줘서 실행하면, 다른 프로세스들(B, C)은 Ready-Queue에서 실행을 기다리도록 하였다.

![Img1](https://user-images.githubusercontent.com/35681772/59989681-32dd0480-967b-11e9-8c42-9944f3157347.png)

Time-Sharing 시스템이 대중화되며 프로그램이 메모리에 동시에 공존해야 하기 때문에, 한 프로세스가 다른 프로세스의 메모리에 접근하여 Read 또는 Write 하는것과 같은 의도치 않은 사용에 대한 Protection의 문제가 부각되기 시작하였다.

---

## 13.3 주소 공간(Address Spaces) : 물리 메모리나 가상 메모리, 레지스터 등의 논리적 실체나 물리적 실체에 대응되는 주소의 범위를 정의한 공간을 말한다.

운영체제는 주소 공간(Address Space)이라는 개념을 가지고 메모리를 사용하기 쉽게한다(easy to use). 주소 공간은 실행 프로그램의 모든 메모리 상태를 가지고 있다.

![img2](https://user-images.githubusercontent.com/35681772/59989689-3e303000-967b-11e9-9604-7b551c890023.png)

주소 공간의 메모리 상태 중 **코드(code, 명령어) 영역** : 명령어 덩어리. 주소 공간의 가장 위쪽에 위치. 코드는 정적이기 때문에 메모리에 저장하기 쉬워 주소 공간의 상단에 배치함. 또한 프로그램이 실행되면서  추가 메모리를 필요로 하지 않는다.

주소 공간의 메모리 상태 중 **스택 영역** : 함수 호출 체인 상의 현재 위치, 지역 변수, 함수 인자와 반환 값 등을 저장. 프로그램이 실행되며 확장 또는 축소될 수 있고, 주소 공간 상에 하단에 위치하여 확장시(사용자가 프로시저를 호출하는 상황 등에서) 위쪽 방향으로 확장됨. 힙 영역과 확장 방향이 반대.

주소 공간의 메모리 상태 중 **힙 영역** : 동적으로 할당되는 메모리를 위해 사용됨. 프로그램이 실행되며 확장 또는 축소될 수 있고, 주소 공간상에 상단(코드 영역 아래)에 위치하여 확장시(사용자가 동적 할당 등으로 더 많은 메모리를 요청하는 상황 등에서) 아래 방향으로 확장됨. 스택 영역과 확장 방향이 반대.

그러나 이런식의 주소 공간 배치는 관례일 뿐 무조건 지켜지는 규칙은 아니다. 다중 스레드가 공존하는 상황에선 이런식의 배치는 동작하지 않는 상황을 초래함.

운영체제가 이렇게 주소 공간이라는 개념으로 **실행 중인 프로그램에게 자신이 특정 주소의 메모리에(예를 들어, 0과 같은) 탑재되어 매우 큰 주소 공간을(예를 들어, 32비트 또는 64비트와 같은) 가지고 있다는 illusion을 주는 것을 운영체제가 메모리를 가상화(Virtualizing Memory) 한다** 고 말한다.

예를 들어, **프로세스 A가 가상 주소(Virtual Address) 0으로 부터 load연산을 수행할 때, 운영체제는 물리 주소 0이 아니라 물리 주소 320KB(A가 탑재된 메모리)를 읽도록 보장해준다.**

---

## 13.4 목표

가상 메모리 시스템(VM)의 목표로는 **투명성(Transparency), 효율성(Efficiency), 보호(Protection)** 가 있다.
  - **투명성(Transparency)** : 운영체제가 실행 중인 프로그램 자신이 전용 물리 메모리를 소유했다는 illusion을 주도록 가상 메모리의 존재를 인지하지 못하도록 하는것.

  - **효율성(Efficiency)** : 운영체제가 시간적 측면과 공간적 측면사이를 잘 조율하여 효율성을 최대화 하는것. 시간적 측면으로는 프로그램이 너무 느리게 실행되서는 안되고, 공간적 측면에서는 가상화를 지원하기 위한 구조를 위해 너무 많은 메모리를 사용해서는 안되기 때문.

  - **보호(Protection)** : 운영체제가 프로세스들과 운영체제 자신을 다른 프로세스로부터 보호하는것. 다른 프로세스나 운영체제의 메모리 내용에 접근하거나 영향을 주지 못하도록 하는것. 보호성질을 이용하여 프로세스들을 서로 **고립(Isolate)** 시켜 자신의 주소 공간 밖의 어떠한 것에도 접근하지 못하도록 한다.
    
---

## 13.5 요약

운영체제의 구성 요소중 **가상 메모리(VM)** 는 프로세스에게 그 프로세스만을 위한 전용 공간이라는 illusion을 제공. 여기에 해당 프로그램의 명령어와 데이터 전부가 저장됨. 운영체제는 하드웨어의 도움을 받아 가상 메모리 주소를 물리 주소로 변환하고, 그러면 그 물리 주소는 특정 정보를 반입하기 위하여 물리 메모리에 전달한다.

---

# 14. Memory API

![img10](https://user-images.githubusercontent.com/35681772/59989706-50aa6980-967b-11e9-8cc2-5c7b24f5b5d3.png)

![img11](https://user-images.githubusercontent.com/35681772/59989712-56a04a80-967b-11e9-91d3-53f0bde40548.png)

![img12](https://user-images.githubusercontent.com/35681772/59989722-5ef88580-967b-11e9-8edf-20767584b70d.png)

---