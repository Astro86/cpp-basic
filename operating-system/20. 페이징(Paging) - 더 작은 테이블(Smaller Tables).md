# 20. 페이징 : 더 작은 테이블(Paging: Smaller Tables)

![img3](https://user-images.githubusercontent.com/35681772/59990506-59e90580-967e-11e9-951b-16ff37f715db.jpg)

페이징의 문제점으로 페이지 테이블의 크기가 이슈가 되었다. 페이지 테이블이 크면 많은 메모리 공간을 차지하게 되기 때문에 페이지 테이블을 어떻게 더 작게 만들까에 대한 내용을 다룬다.
페이지 크기가 개당 4KB(2^12바이트)이고, PTE는 각각 4바이트인 32비트 주소 공간(2^32바이트)를 예로들면, 주소 공간에는 약 백만 개(2^32 / 2^12)의 페이지들이 존재하게 되고, 여기에 페이지 테이블 항목(PTE)을 곱하면 4바이트 * 백만 이 되어 하나의 페이지 테이블의 크기가 약 4MB가 된다. 더군다나 프로세스당 페이지 테이블을 하나씩 가지고있어야 하기 때문에 페이지 테이블의 크기는 이슈가 되지 않을 수 없다.

Paging에서의 이슈는 

1) 속도 - TLB로 해결됨 
2) Size - 남아있는 문제

따라서 이번엔 그 크기를 어떻게 줄일것인지가 관전 포인트가 되겠다.

---

## 20.1 간단한 해법 : 더 큰 페이지

정말 간단하게 페이지의 크기를 증가시켜서 전체 개수를 줄이는 방법이다. 32비트 주소 공간에서 이전에 페이지 하나당 4KB였다면 페이지 하나당 16KB로 페이지의 크기를 증가시킨다. 이렇게 되면 18비트의 VPN과 14비트의 Offset을 갖게 되어 각 PTE의 크기가 4바이트로 동일하다면 페이지 테이블에 VPN의 개수만큼인 2^18개의 항목이 존재하게 되고, 페이지 테이블의 총 크기는 1MB가 된다.
그러나 이렇게 페이지 테이블의 크기를 증가시키면 다음과 같은 부작용을 수반한다.
  - *내부 단편화(Internal Fragmentation)* : 페이지 내부의 낭비 공간이 증가. 응용 프로그램이 여러 페이지를 할당 받았지만 할당 받은 페이지의 일부분만 사용하게 되어 시스템의 메모리가 금방 고갈된다.

페이지 단위로 할당을 받기 때문에 그 페이지 크기를 키우게 되면 '노는' 공간들이 많아진다.
따라서 많은 현대 시스템은 비교적 작은 페이지들을 사용하고 있다.

---

## 20.2 하이브리드 접근 방법 : 페이징과 세그먼트

두 가지 방법을 조합하는 것을 하이브리드(Hybrid)라고 하는데, 페이징과 세그멘테이션을 결합하여 페이지 테이블의 크기를 줄이는 방법을 의미한다. 

![img1](https://user-images.githubusercontent.com/35681772/59990512-63726d80-967e-11e9-9689-0cee0eebcbed.png)

![img1](https://user-images.githubusercontent.com/35681772/59990519-69684e80-967e-11e9-95ab-fc239601d3d8.jpg)

![img4](https://user-images.githubusercontent.com/35681772/59990527-6ec59900-967e-11e9-8a03-1b640067bc3b.jpg)


1KB 크기의 페이지를 갖는 16KB 주소 공간이 위와같이 존재할 경우, 그림에서 보이는 바와 같이 페이지 테이블 대부분이 비어있게 된다. 이는 메모리의 낭비로 이어지게 되어 이를 개선하기 위해 *각 논리 세그먼트마다 따로 페이지 테이블을 두는* 방법이 하이브리드 접근 방법이다. 즉 코드, 힙, 스택 세그먼트에 대해 각각 linear page table을 두겠다는 것이다.

따라서 세그멘테이션에서의 Base & Bound 레지스터의 개념을 그대로 차용한다. 베이스(Base) 레지스터는 세그먼트의 페이지 테이블의 시작 주소를 갖고, 바운드(Bound) 레지스터는 페이지 테이블의 끝을 나타내기 위해서 사용한다. 

예시로 4KB 페이지를 갖는 32비트 가상 주소 공간이 4개의 세그먼트(00 : 미사용, 01 : 코드, 10 : 힙, 11 : 스택)로 나뉘어 진 경우 아래와 같이 표현될 수 있다.

![img2](https://user-images.githubusercontent.com/35681772/59990539-771dd400-967e-11e9-9b2b-ab5c3da49045.png)

Segment Number를 뽑아내서 접근해보면 page table이 나오게 되고 거기에서 VPN을 가져와서 PTE에 접근하겠다는 아이디어다.

하드웨어에 세 개(코드, 힙, 스택)의 바운드 레지스터가 존재하고, 각 세그먼트의 베이스 레지스터는 각 세그먼트 페이지 테이블의 시작 물리 주소를 갖게 된다. 또 한 프로세스에서 세그먼트당 하나의 페이지 테이블을 갖기 때문에 각 프로세스들은 총 세개의 페이지 테이블을 갖게 된다.

![img3](https://user-images.githubusercontent.com/35681772/59990544-7e44e200-967e-11e9-9cd6-1b08535c703c.png)

TLB 미스가 발생하여 직접 물리 메모리에서 데이터를 가져올 때, 하드웨어는 세그먼트 비트(SN)을 이용하여 어떤 베이스와 바운드 쌍을 사용할지 결정하게 된다. 여기서 관전 포인트는 추가적으로 SN을 추출하여 해당되는 베이스 레지스터를 사용하는 점 이다.

하이브리드 기법에서의 핵심은 세그먼트마다 베이스 & 바운드 레지스터가 따로 존재한다는 것이다. 바운드 레지스터의 기본 개념과 동일하게 페이지 테이블에서의 바운드 레지스터는 해당 세그먼트의 최대 유효 페이지의 개수를 나타낸다. 

이러한 방식으로 *스택과 힙 사이의 할당되지 않은 페이지들은 페이지 테이블 상에서 더이상 공간을 차지하지 않는다.*

이 방법의 문제점으로는
  1) 세그멘테이션 방법을 사용하기 때문에 **유연성이 떨어진다** (not quite as flexible as we would like) : 드물게 사용되는(sparsely used) 힙의 경우에는 여전히 페이지 테이블의 낭비를 초래할 수 있다.
  2) 외부 단편화(external fragmentation)를 유발한다 : 메모리가 페이지 사이즈의 unit들로 관리되기 때문에, PTE의 갯수에 대응되는 만큼의 공간을 차지하게 되어 빈 공간의 관리가 이슈가 된다.

따라서 페이지 테이블의 크기를 감소시키는 더 나은 방법들이 고려되었다.

---

## 20.3 멀티 레벨 페이지 테이블(Multi-level Page Tables)

이번엔 세그멘테이션을 사용하지 않고 페이지 테이블의 크기를 줄이는 방법에 대해 알아본다. 여기의 핵심 이슈는 *"어떻게 하면 사용하지 않는 주소 공간을 페이지 테이블에서 제거할수 있을까?"* 이다. 

**멀티 레벨 페이지 테이블은 *트리 구조* 로 페이지 테이블을 구현하여 이러한 문제점을 개선** 하였다.

멀티 레벨 페이지 테이블의 기본 개념은 아래와 같다.
  - 페이지 테이블을 페이지 크기의 단위로 나눈다(chop up the page table into page-sized units).
  - 페이지 테이블의 페이지가 유효하지 않은 항목만 있을 경우, 해당 페이지를 할당하지 않는다(if an entire page of page-table
entries (PTEs) is invalid, don’t allocate that page of the page table at all).
  - 이렇게 페이지 테이블의 페이지가 유효한지 유효하지 않은지를 파악하는데에 있어 **페이지 디렉토리(page directory)** 라는 자료구조를 사용하여 페이지 테이블 각 페이지의 할당 여부와 위치를 파악한다.
  - 즉, **페이지 디렉토리**는 페이지 테이블을 구성하는 각 페이지의 위치 정보와 유효성을 파악하는데에 사용된다.

linear page table의 경우 페이지 몇개에 걸치던 간에 연속적인 공간에 저장이 되어야한다. 그러나 page directory 개념을 도입하게 되면 virtual address에 있는 모든 엔트리들을 page 단위로 쪼갠다음 거기서 유효성을 판단하여 관리하겠다는것.

페이지 단위 페이지 테이블을 쪼개서 흩뜨려놓고 관리가 가능하다. 또 PTE중 valid한게 하나라도 있어야 page를 할당해주겠다는것.

page table의 PTE 하나는 page 하나를 represent한다. 

마찬가지로 page directory의 PDE 하나는 페이지 테이블을 represent하게 된다.

![img5](https://user-images.githubusercontent.com/35681772/59990550-8866e080-967e-11e9-9621-3bee69403021.png)

좌측 선형 페이지 테이블에서는 파란색으로 표시된 공간들이 사용되지 않고 있지만 페이지 테이블에서 항목들이 할당이 되어있다(PFN 202, PFN 203으로). 

우측 멀티 레벨 페이지 테이블에서는 PFN 201, PFN 204의 두개의 유효한 페이지만 메모리에 존재하게 된다. 멀티 레벨 페이지 테이블에서는 *페이지 디렉토리를 이용하여 페이지 테이블의 어떤 페이지들이 할당되었는지를 관리하게 된다.*

페이지 디렉토리의 각 항목은 페이지 테이블의 한 페이지를 나타내는데, 이를 *페이지 디렉토리 항목(page directory entries, PDE)* 라 지칭한다. 

PDE의 구성 요소는 PTE(page table entries)와 유사한데, 유효(valid)비트와 페이지 프레임 번호(PFN)를 가지고 있다. 여기서 **PDE 항목이 유효하다는 것은 PFN을 통해 그 항목이 가지고 있는 페이지들 중 *최소한 하나* 가 유효하다는 것을 의미한다.** 따라서 PDE의 valid bit이 0인경우 해당 PDE는 실제 페이지가 할당되어 있지 않은것이 된다.

멀티 레벨 페이지 테이블의 장점은 다음과 같다.
  1) 사용된 주소 공간의 크기에 비례하여 페이지 테이블 공간이 할당된다. 따라서 보다 작은 크기의 페이지 테이블로 주소 공간을 표현할 수 있다.
  2) 페이지 테이블을 페이지 크기로 분할함으로써 메모리 관리가 용이하다(선형 페이지 테이블에서는 연속된 물리 메모리 공간을 차지하므로 요청에 맞는 연속된 빈 물리 메모리를 찾아내야 하지만, 멀티 레벨 페이징에서는 페이지 디렉토리를 이용하여 위치 파악을 하고있으므로 공간 할당이 매우 유연).

멀티 레벨 페이지 테이블의 단점은 다음과 같다.
  1) TLB 미스 시, 주소 변환을 위해 두 번의 메모리 로드가 발생하는 추가 비용 발생 : 페이지 디렉토리 접근에 한번 PTE 접근에 한번 총 두 번의 메모리 로드 필요)
  2) 페이지 테이블 검색이 단순 선형 페이지 테이블의 경우보다 복잡해짐

![img6](https://user-images.githubusercontent.com/35681772/59990562-90bf1b80-967e-11e9-8080-57ff8e6e429e.png)

![img7](https://user-images.githubusercontent.com/35681772/59990569-974d9300-967e-11e9-9a67-d6e918cab20b.png)

멀티 레벨 페이지 테이블에서는 1st Level Page Table(=Page Directory)은 단지 다른 페이지 테이블의 주소를 저장하고 있을 뿐이다. 즉, 1st Level Page Table Entry는 다른 레벨의 페이지 테이블을 가리키고 있는 것이다.

따라서 페이지 디렉토리를 통하여 다른 페이지 테이블로 접근을 하는 구조인 멀티 레벨 페이징에서는 모든 테이블을 메모리에 두지 않아도 되게 된다.

또한 page directory를 이용해서 indexing이 가능하게 된다.

페이지 디렉토리는 다른 페이지 테이블에 접근이 가능하기위해 메모리에 위치해야만 한다.

즉, 하나의 페이지 테이블의 정보를 담는 페이지 테이블과 실제 프로그램 메모리에 접근하는 페이지 테이블 두 레벨로 나뉘어 관리한다는 것이다.

**단 이 때, 페이지 테이블들의 페이지는 분산되어 있을지언정, _페이지 디렉토리는 linear하게 저장되게 된다._**

---

### 멀티 레벨 페이징 예제

64바이트 페이지를 갖는 16KB의 작은 주소 공간이 있을 때, 이는 14비트의 가상 주소 공간이 된다(VPN 8비트, Offset 6비트). VPN 비트의 수는 (16 * 2^10 / 64 = 256 = 2^8)로 구할 수 있고, Offset은 log(페이지 크기)로 구할 수 있다. 따라서 선형 페이지 테이블에서는 2^8 = 256개의 엔트리로 구성이 된다.

![img8](https://user-images.githubusercontent.com/35681772/59990580-9fa5ce00-967e-11e9-905d-3a9925d84dee.png)

위 예시에서는 선형 페이지 테이블을 나타내고 있는데 맨 위부터 Page0 : 코드, Page1 : 코드, Page4 : 힙, Page5 : 힙, ... , Page254 : 스택, Page255 : 스택 순이다. 이 때, 선형 페이지 테이블은 2^8(256)개의 엔트리로 구성된다.

이 주소 공간을 2레벨 페이지 테이블로 구성해보면, 각 PTE가 4바이트라 가정했을 경우 페이지 테이블의 크기는 256(엔트리의 수) * 4바이트 = 1KB가 된다. 페이지가 64바이트이므로 1KB의 페이지 테이블은 16개의 64바이트 페이지들로 분할되고, 각 페이지에는 16개의 PTE가 있다.

![img9](https://user-images.githubusercontent.com/35681772/59990591-a7657280-967e-11e9-871b-18a486e4f862.png)

그 다음으로 VPN으로부터 페이지 디렉토리 인덱스를 추출해보면, 페이지 디렉토리에는 페이지 테이블의 각 페이지를 가리킬 수 있어야하기 때문에 총 16개의 PDE를 필요로 한다. 따라서 상위 4비트(2^4 = 16)를 할당해준다.

VPN에서 PDI(Page Directory Index)를 추출하고나면 `PDEAddr = PageDirBase + (PDIndex * sizeof(PDE))` 로 PDE의 주소를 얻어낼 수 있다.

따라서 그렇게 접근한 PDE가 유효하다면(무효인 경우 예외발생), 이 PDE가 가리키고 있는 PTE(Page Table Entry)에 접근하기위해 VPN의 나머지 4비트를 사용한다. 이를 PTI(Page Table Index)라 지칭한다. PTI는 페이지 테이블 자체 인덱스를 나타낸다. 따라서 `PTEAddr = (PDE.PFN << SHIFT) + (PTIndex * sizeof(PTE))` 로 PTE의 주소를 얻어 접근할 수 있다.


![img12](https://user-images.githubusercontent.com/35681772/59990600-ae8c8080-967e-11e9-91fb-6e6907e597fe.png)

이와같은 순서로 실제 물리 메모리 주소를 얻어낼 수 있게 된다. 가상 페이지 번호 254를 2진수로 나타내서 앞 4자리를 통해 Physical Frame 101로 접근하고, 거기에서 그 다음 4자리를 이용해서 물리 페이지 55에 존재하는 것을 알아내게 된다. 그 다음 Offset 000000과 PFN을 결합하여 다음과 같이 물리 주소를 얻어낸다.

 `PhysAddr = (PTE.PFN << SHIFT) + offset = 00 1101 1100 0000 = 0x0DC0.`

![img4](https://user-images.githubusercontent.com/35681772/59990611-b6e4bb80-967e-11e9-8937-6469cbb2004a.png)

다른 예제로 조금더 입체적으로 표현하면 위와같다.

---

### 2레벨 이상 사용하기

![over2level1](https://user-images.githubusercontent.com/35681772/59990621-c19f5080-967e-11e9-9445-d5d50ebaaf65.png)

페이지 디렉토리가 너무 커지게 되는 경우를 보자.

페이지 당 크기가 512바이트, 30비트 가상 주소공간에서는 21비트의 가상 페이지 번호와 9비트의 오프셋을 갖게 된다.

한 페이지에 몇 개의 PTE를 저장할 수 있을지 계산해보면 한 페이지 크기가 512바이트고 PTE의 크기가 4바이트인 경우 한 페이지에 128개의 PTE를 넣을 수 있다. 따라서 이는 VPN중 하위 7비트에 표현된다.

그러면 나머지 할당된 페이지 디렉토리 인덱스의 경우 21 - 7 = 14개의 비트를 사용하게 된다는 것이고, 2^14 만큼의 페이지를 갖게 되는 것이다. 즉, 페이지 디렉토리를 위해 128 페이지의 연속된 메모리 공간을 필요로 하게 된다. 이는 멀티 레벨 페이지 테이블의 취지와 맞지 않게 된다. 연속된 메모리 공간을 사용하지 않고자 페이지 디렉토리를 사용하는 것이기 때문.

페이지 디렉토리가 너무 커지게 되면 레벨을 늘려 트리 구조를 더 뻗어나가는 형식으로 구현이 가능하다. 다시말해 페이지 디렉토리 자체를 멀티 페이지들로 나누어서 트리의 단계를 늘리는 것이고, 페이지 디렉토리의 페이지들을 가리키는 새로운 페이지 디렉토리를 추가적으로 두는 것이다.

다만 이렇게 할 경우 실제 주소를 구하는 데 드는 작업이 상당하다. 레벨에 해당하는 만큼의 추가적인 메모리 접근이 발생하게 된다.

---

### 변환 과정 : TLB를 주목

![img14](https://user-images.githubusercontent.com/35681772/59990628-c95ef500-967e-11e9-9141-1b5ca5601677.png)

우선 TLB를 검사하여 히트가 되면 페이지 테이블 참조 없이 물리 주소를 직접 구성하고, TLB 미스가 난 경우 멀티 레벨 페이지 테이블의 모든 단계를 거쳐 물리 주소를 구하게 되는것을 알 수 있다.

page directory로 부터 특정 페이지 테이블을 얻어올 수 있다. 그래서 그 페이지 테이블로 접근하여 PTE를 읽어온다. 그리고 그 PTE로 부터 PFN을 읽어들인다.

---

![img5](https://user-images.githubusercontent.com/35681772/59990633-d0860300-967e-11e9-99a7-dd86327cc7aa.jpg)

---

## 20.4 역 페이지 테이블

역 페이지 테이블(inverted page table)방법은 프로세스당 하나씩 페이지 테이블을 두는 대신 시스템에 단 하나의 페이지 테이블만을 둔다. 그리고 물리 페이지를 가상 주소 상의 페이지로 변환하도록 한다. 그리고 페이지 엔트리는 어떤 프로세스가 이 페이지를 사용중이고, 프로세스의 가상 페이지가 어떤 물리 페이지에 매핑이 되는지를 나타낸다.

즉, 지금까지 모든 page table은 per process page table이었다. 그러나 이 개념에선 global page table을 하나 둬서 끝내자는 것인데, 여기서도 마찬가지로 Key, Value 구조로 해시를 써서 시도하려 했기 때문에 큰 성과를 거두지 못함.

---

## 20.5 페이지 테이블을 디스크로 스와핑하기

페이지 테이블의 크기 이슈때문에 많은 시도를 하더라도 여전히 모든 페이지 테이블을 메모리에 상주시키기에는 비용이 클 수 있다. 따라서 *커널 가상 메모리에 페이지 테이블을 위치시키고, 시스템의 메모리가 부족할 경우 페이지 테이블들을 디스크로 스왑(Swap)하기도 한다.* 

---

## 20.6 요약

페이지 테이블의 실제 구성요소를 다뤄봤다. 공간을 많이 소모하는 테이블 구조일수록 TLB 미스의 처리속도가 빨라지고, 공간을 작게 차지하는 테이블 구조를 사용할수록 상황은 반대가 된다(Trade-Off). 따라서 적절한 자료 구조를 결정할 수 있어야 한다.


