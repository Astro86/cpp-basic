# 26. 병행성(Concurrency) : 개요(An Introduction)

**쓰레드(Thread)** 를 다뤄본다.

멀티 쓰레드 프로그램은 하나 이상의 실행 지점(독립적으로 불러 들여지고 실행될 수 있는 여러 개의 PC 값)을 가지고 있다.

쓰레드들은 주소 공간을 공유하기 때문에 동일한 값에 접근할 수 있다.

쓰레드는 어디서 명령어를 불러 들일지 추적하는 프로그램 카운터(PC)와 연산을 위한 레지스터들을 가지고 있다.

_두 개의 쓰레드가 하나의 프로세서에서 실행 중이라면 실행하고자 하는 쓰레드간 교환은 **Context switch** 를 통해 이루어 진다._ 쓰레드 간 context switch 는 쓰레드 T1이 사용하던 레지스터들을 저장하고 쓰레드 T2가 사용하던 레지스터의 내용으로 복원한다는 점에서 프로세스의 context switch와 유사하다. 다만 프로세스의 context switch에서 프로세스의 상태를 PCB(Process Control Block)에 저장하듯, _쓰레드간 context switch에선 쓰레드들의 상태를 저장하기 위해 **TCB(Thread Control Block)** 이 사용된다._

프로세스의 경우와 달리 쓰레드간의 context switch에서는 주소 공간을 그대로 사용한다(사용하고 있던 페이지 테이블을 그대로 사용한다).

또한 프로세스의 경우와 달리, 멀티 쓰레드 프로세스에선 각 쓰레드가 독립적으로 실행되며, 쓰레드가 실행하기 위해 여러 루틴들을 호출할 수 있다. 즉, 주소 공간에는 하나의 스택이 아니라 쓰레드마다 스택이 할당되어 있다. 두 개의 쓰레드를 가지는 멀티 쓰레드 프로세스의 주소 공간은 단일 쓰레드 프로세스의 주소 공간과 다르다.

![img1](https://user-images.githubusercontent.com/35681772/59991021-856cef80-9680-11e9-86ea-57f3781c73e0.png)

위 그림에서 멀티 쓰레드의 주소 공간에는 두 개의 스택이 존재하는 것을 확인할 수 있다. 스택에서 할당되는 변수들이나 매개변수, 리턴 값, 그 외 스택에 넣는 것들은 해당 쓰레드의 스택인 쓰레드-로컬 저장소(Thread-Local Storage)에 저장된다.

이렇게 스택이 여러개가 됨으로써 주소 공간의 배치가 무너져 스택과 스택 사이 빈공간이 추가적으로 생기게 되더라도, 이것이 초래하는 문제는 크지 않다. 재귀 호출을 아주 많이 하지 않는 이상 대부분의 경우에는 문제가 되지 않는다.

---

**쓰레드를 사용하는 이유**

1) **병행성(parallelism)** : 가령 배열 두 개의 같은 인덱스에 해당하는 element들의 합을 또 다른 배열에 담는 경우, 하나의 CPU를 가지고(single-threaded) 연산을 수행하는 것 보다 여러 CPU(multiple CPUs)를 가지고 수행하는 것이 해당 프로그램의 퍼포먼스 측면에서 더 우수하다. 이를 **parallelization** 이라 부르고, 이렇게 병렬적으로 작업을 수행하는 것이 현대 하드웨어를 이용함에 있어 훨씬 더 많은 성능 향상을 가져온다(그리고 더 일반적이다).

2) **I/O를 하는 동안 프로그램의 수행이 지연되는것을 피하기 위함** : 내가 만든 프로그램에서 I/O요청을 수행하는 경우 만약 단일 쓰레드의 경우 해당 요청을 수행하는 동안 프로그램은 수행을 멈추게 된다(수행 완료까지 더 많은 작업이 남았음에도 불구하고). 따라서 하나의 쓰레드가 I/O 처리를 하는 동안 다른 나머지 처리를 진행하도록 추가적인 쓰레드를 사용하면 전체적인 수행시간을 줄일 수 있다. 이러한 이유로 많은 server-based application(web servers, DBMS 등)의 구현에 쓰레드가 빠지지 않고 등장하게 된다.

위의 두 경우에서 물론 멀티 쓰레드 방식이 아닌 멀티 프로세스 방식을 사용할 수 있다. 하지만 **멀티 쓰레드 방식은 주소 공간을 공유** 하기 때문에, 데이터를 공유하여 처리하는 등의 방식에 불가피하게 사용될 수 밖에 없다. 멀티 프로세스 방식은 완전히 독립적인 또 다른 프로그램을 수행할 때 사용하게 된다.

---

## 26.1 예제 : 쓰레드 생성(An Example : Thread Creation)

![img2](https://user-images.githubusercontent.com/35681772/59991026-8dc52a80-9680-11e9-961a-ed9b437e1e4c.png)

위 예제의 프로그램에서 한 쓰레드는 "A" 라고 출력하고, 다른 쓰레드는 "B" 라고 출력하는 독립적인 두 개의 쓰레드를 생성한다.

메인 프로그램은 각각 mythread() 함수를 실행할 두 개의 쓰레드를 생성한다. 이 때 각 mythread() 함수는 서로 다른 인자를 전달받는다.


![img4](https://user-images.githubusercontent.com/35681772/59991030-94ec3880-9680-11e9-9b10-0784d547fb21.png)

![img5](https://user-images.githubusercontent.com/35681772/59991033-99b0ec80-9680-11e9-98eb-3ae768f206b5.png)

![img6](https://user-images.githubusercontent.com/35681772/59991035-9fa6cd80-9680-11e9-8619-d676f6178b86.png)

위의 3개의 각기 다른 실행 추적에서 확인할 수 있는것 처럼, _스케줄러가 특정 시점에 실행하는 쓰레드에 따라 다양한 순서가 있을 수 있다._ 준비(Ready) 상태에서 실행은 되지 않을 수 있고(실행 추적 1), 쓰레드가 생성되면 즉시 실행될 수도 있다(실행 추적 2). 만약 스케줄러가 쓰레드 2를 먼저 실행하면 "B"가 "A" 보다 먼저 출력될 수도 있다(실행 추적 3). 두 개의 쓰레드(T1 과 T2)를 생성한 후 메인 쓰레드는 pthread_join()을 호출하여 특정 쓰레드의 동작 종료를 대기한다.

쓰레드의 생성에서는 실행 할 명령어들을 갖고 있는 새로운 쓰레드가 생성되고, 생성된 쓰레드는 호출자와는 별개로 실행된다.

결과적으로 위에서 알 수 있듯, 쓰레드는 언제 실행되는지 알기 어렵다.

---

## 26.2 더 어려운 이유 : 데이터의 공유(Why It Gets Worse : Shared Data)

쓰레드의 생성 방법과 스케줄러에 의해 실행 순서가 바뀔 수 있다는 것을 염두한 채, 전역 공유 변수를 갱신하는 두 개의 쓰레드를 사용한 예제를 보자.

![img8](https://user-images.githubusercontent.com/35681772/59991046-a9303580-9680-11e9-93dd-3291e932adc4.png)

위 예제 코드에서는 다음과 같은 사항들을 고려하였다.

첫째, 쓰레드를 생성하는 루틴과 조인하는 루틴이 실패할 경우 간단하게 종료하도록 래퍼 함수를 만들었다.

둘째, 작업자 쓰레드(worker thread)를 위해 두 개의 독립된 함수를 구성하는 대신 하나의 단일 코드를 사용하였다.

셋째, 각 작업자가 무엇을 하려는지 알 수 있다. 즉, 루프를 돌며 공유 변수인 counter를 증가시키는 것이다. 각 worker마다 counter 변수를 1e7(천만) 만큼 증가시키므로 최종적으로 얻고자하는 값은 20,000,000 이다(worker thread가 2개 이므로).

![img9](https://user-images.githubusercontent.com/35681772/59991053-af261680-9680-11e9-8750-f9b2ccc9c2d4.png)

이 결과가 우리가 기대한 결과값이 되겠다.

하지만 위 예제를 출력할 경우 기대한 20,000,000이라는 숫자가 나오지 않고 아래와 같은 엉뚱한 결과를 얻게 된다. 또한 매 실행마다 최종 counter 값이 변경되는 것을 알 수 있다.

![img10](https://user-images.githubusercontent.com/35681772/59991059-b51bf780-9680-11e9-8df5-a32fe568ef51.png)

![img13](https://user-images.githubusercontent.com/35681772/59991068-bbaa6f00-9680-11e9-815c-4411b7303da9.png)

---

## 26.3 제어 없는 스케줄링(The Heart Of The Problem : Uncontrolled Scheduling)

왜 이런 현상이 발생했는지는 counter 갱신을 위해서 컴파일러가 생성한 코드의 실행 순서를 이해하면 된다. 

![img11](https://user-images.githubusercontent.com/35681772/59991078-c238e680-9680-11e9-8446-db4c633e3a71.png)

x86에서 counter를 증가하는 코드의 순서는 위와 같다. 0x8049a1c 는 counter 변수의 위치 주소라고 가정한다.

![img15](https://user-images.githubusercontent.com/35681772/59991087-c82ec780-9680-11e9-973f-b5de8cc626af.png)

위 과정을 간단히 말하자면 mov 명령어가 source 메모리 주소의 값을 읽어들인 후 destination 인 eax 레지스터에 넣는다. 그리고 source 값인 1을 destination 인 eax에 더한다(add). 그 후 source 인 eax 레지스터의 값을 destination 인 메모리 주소(counter 변수)로 옮겨 저장한다.

이 상황에서 쓰레드 T1 이 mov → add → mov 인 한 번의 로직에 있어 add 까지만 수행하였는데 timer interrupt 가 발생하여 운영체제가 실행 중인 쓰레드의 PC 값과 eax를 포함하는 레지스터들 등의 현재 상태를 해당 쓰레드의 TCB에 저장했다고 하자. 

그 후 쓰레드 T2가 mov → add → mov 인 한 번의 로직을 수행하는데, 이 때의 counter 값은 아직 50이므로 한 번의 로직을 완료하여 50에서 51로 변경하였다. 

다시 timer interrupt가 발생하여 쓰레드 T1으로 context switching이 일어났다고 하자. 쓰레드 T1이 마지막 mov 명령어 수행 할 차례다. 그래서 counter 변수에 mov 를 수행하여 51 → 51이 덮어 씌워지게 된다.

의도한 대로 연산이 수행된다면 counter 값은 52가 되어야 한다. 하지만 timer interrupt에 의해 예측할 수 없는 시점에 context switching이 발생하여 위와 같은 결과가 나타나게 된다.

위 예시에서처럼 _명령어의 실행 순서에 따라 결과가 달라지는 상황을 **경쟁 조건(race contidion)** 이라고 부른다._

이 경우 적절한 때에 context switching이 실행되지 않아 잘못된 결과를 얻게 된다.

**결정적(deterministic) 결과(컴퓨터의 작동에서 일반적으로 발생하는 이상적인 결과)** 가 아니라 **비결정적(inteterminate)_ 결과(결과가 어떠할 지 알지 못하거나, 실행할 때마다 결과가 다른 경우)** 가 발생하는 것이다. 

_멀티 쓰레드가 같은 코드를 실행할 때 경쟁 조건(race condition)이 발생하는 이러한 코드 부분_ 을 **임계 영역(critical section)** 이라고 부른다. 즉, _공유 변수(공유 자원)를 접근하는, 하나 이상의 쓰레드에서 동시에 실행되면 안 되는 코드_ 를 critical section 이라 하는 것이다.

따라서 이 critical section 에 필요한 것은 **상호 배제(mutual exclusion)** 이다. 상호 배제는 _하나의 쓰레드가 임계 영역 내의 코드를 실행 중일 때는 다른 쓰레드가 실행할 수 없도록 보장해준다._

---

## 26.4 원자성에 대한 바람(The Wish For Atomicity)

critical section에 대한 해결 방법 중 하나로 강력한 명령어 한 개로 의도한 동작을 수행하여 인터럽트 발생 가능성을 원천적으로 차단하는 방법이 있다. 

![img16](https://user-images.githubusercontent.com/35681772/59991098-cfee6c00-9680-11e9-8051-31adb3f69bb3.png)

이렇게 한 번의 명령어로 앞서 3단계에 거친 명령어들을 직접 수행할 수 있다면 context switch가 발생하여도 위 명령어가 실행 되었거나, 실행되지 않았거나 두 경우밖에 존재하지 않기 때문에 critical section이 해결된다. 이러한 특성을 atomic한 특성이라고 말한다.

atomic 한 특성은 '하나의 단위'를 이루며 "all or none"의 특징을 갖는다.

따라서 위처럼 하나의 명령어로 대신할 수 있는 경우 critical section이 해결될 수 있지만 사실상 불가능하다.

따라서 하드웨어적으로 '동기화 함수(synchronization primitives)를 둬서 병행 실행(concurrent execution)상황에서의 critical section에 하나의 쓰레드만 실행하도록 구성된 멀티 쓰레드 프로그램을 작성하는 방법을 알아보도록 하자.

---

**병행성 관련 용어**

**임계 영역(critical section)** : 변수나 자료 구조와 같은 _**공유 자원**을 접근하는 코드의 일부분을 말한다._

**경쟁 조건(race condition)** : 멀티 쓰레드가 거의 동시에 critical section을 실행하려고 할 때 발생하며, 공유 자료 구조를 모두가 갱신하려고 시도할 경우 의도하지 않은 결과를 발생시킨다.

**비결정적(indeterminate) 프로그램** : 하나 또는 그 이상의 경쟁 조건을 포함하여 그 실행 결과가 각 쓰레드가 실행된 시점에 의존하기 때문에, 프로그램의 결과가 실행할 때 마다 다르게 되어 일반적으로 기대하는 결과가 도출되지 않는 프로그램.

반대로 **결정적** 은 컴퓨터 시스템에서 일반적으로 기대하는 바를 지칭한다.

---

## 26.5 또 다른 문제 : 상대 기다리기( One More Problem: Waiting For Another)

지금껏 다룬 병행성 이슈에서는 공유 변수 접근에 관련된 쓰레드 간 상호 작용 문제였다.

실제로는 하나의 쓰레드가 다른 쓰레드가 어떤 동작을 끝낼 때 까지 대기해야 하는 상황도 발생한다. 

따라서 이후에 동기화 함수에 대한 내용 및 멀티 쓰레드 프로그램에서 필수적인 sleep/waking interaction에 대해 다루게 된다.

---

## 26.6 정리 : 왜 운영체제에서?( Summary: Why in OS Class?)

운영체제에서 병행성의 이슈를 다루는 이유는 운영체제가 최초의 병행 프로그램이기 때문이다. 따라서 운영체제 내에서 사용할 목적으로 병행성에 관한 다양한 기법들이 개발되었다.

이후에 멀티 쓰레드 프로그램이 등장하며 응용 프로그래머들도 이 문제를 고민하게 되었다.

가령 두 개의 프로세스가 임의의 파일에 둘 다 write()를 수행하여 데이터를 파일에 덧붙이는 경우, timer interrupt가 언제든 발생할 수 있어 이런 공유 자료 구조를 갱신하는 코드는 critical section이 된다.

적절한 동기화 함수를 사용하여 이 critical section을 control하는 방법을 알아보도록 한다.

---
