# 30. 컨디션 변수 (Condition Variables)


락 만으로는 병행성을 완벽히 갖춘 프로그램을 작성할 수 없다.

쓰레드가 계속 진행하기 전에 어떤 조건이 참인지를 검사해야 하는 경우가 많이 발생한다.

아래 예시에서 처럼 '자식 쓰레드가 작업을 끝내면 부모 쓰레드가 작업을 하게 하고자, 자식 쓰레드의 작업이 끝났는지를 검사하고 싶은 경우' _공유 변수 done_ 을 사용하여 구현을 하면 제대로 동작하지만, 부모 쓰레드에 CPU가 왔을 때, while문에서 의미없는 spin만 하게 되므로 CPU 시간을 낭비하는 셈이 된다.

![img1](https://user-images.githubusercontent.com/35681772/59991466-78e99680-9682-11e9-8227-ab72efd110af.jpg)

따라서 부모 쓰레드는 특정 조건이 참이 될 때까지(자식 쓰레드의 작업이 완료되는 경우) sleep 하는것이 더 효율적이다.

---

## 30.1 정의와 루틴들 (Definition and Routines)

조건이 참이 될 때까지 기다리기 위해 **컨디션 변수(conditional variable)** 을 이용한다.

컨디션 변수는 일종의 큐(queue) 로서, **쓰레드가 어떤 특정 조건이 참이 되길 기다리며 대기할 수 있는 큐** 이다.

다른 쓰레드가 상태나 조건을 변경시켰을 때, 대기 중이던 쓰레드를 깨우고 조건에 따라 시그널을 보내서 작업을 계속 이어갈 수 있도록 한다. 이 때, 깨어나는 쓰레드는 여러개가 될 수 있다.

`pthread_cond_t c;` 와 같이 선언하여 컨디션 변수 c를 선언할 수 있다. 컨디션 변수에는 다음 두개의 연산을 가지고 있다.

![img26](https://user-images.githubusercontent.com/35681772/59991474-80a93b00-9682-11e9-930b-7f72bae0e7f5.png)

  - wait() : 쓰레드가 스스로를 잠재우기 위해 호출하는 함수
  - signal() : 컨디션 변수의 대기 큐에서 sleep 중인 쓰레드를 깨울 때 호출하는 함수. signal()을 호출하는 쓰레드가 무엇인가를 변경했기 때문에 대기 큐의 대기 조건들 중에 그 변경으로 인해 참이되는 조건을 가진 쓰레드를 깨우기 위함.

wait() 에서 mutex를 매개변수로 사용하고 있는데, _wait()이 호출될 때 mutex는 잠겨있었다고 가정한다. wait()의 역할은 락을 해제하고 호출한 쓰레드를 sleep 시키는 것이다. 어떤 다른 쓰레드가 signal()을 호출하여 쓰레드가 깨어나면, **wait() 에서 리턴하기 전에 반드시 락을 다시 획득해야 한다.**_

그러므로 조건이 만족되어 _sleep 상태에서 깨어났더라도 락을 획득하지 못하면 다시 sleep 상태로 들어간다._

![img2](https://user-images.githubusercontent.com/35681772/59991484-89017600-9682-11e9-9e97-b01c29d5a81f.jpg)

위 join 이 발생하는 경우는 다음 두가지 중 하나이다.

  - 부모 쓰레드가 자식 쓰레드를 생성하고, 부모 쓰레드가 계속 실행되어 thr_join() 을 호출함으로써 자식 쓰레드가 끝나기를 기다리는 경우
    - 이 경우 부모 쓰레드가 락을 획득하고 자식이 끝났는지(done이 1인지를) 검사한 후에, 자식이 끝나지 않았으므로 wait()을 호출하여 스스로를 sleep 상태로 바꾼다. 그리고 락을 해제한다.
    - 그 이후 자식 쓰레드가 실행되어 child 메세지를 출력하고 thr_exit()을 호출하여 락을 획득한 다음 done 변수를 1로 설정하고 signal() 을 보내 부모 쓰레드를 깨운다. 그리고 락을 해제한다.
    - 마지막으로, 호출했던 wait()에서 락을 획득한 채로 리턴하여 부모 쓰레드가 실행되며 parent 메세지를 출력한 뒤 종료된다.

  - 부모 쓰레드가 자식 쓰레드를 생성하여, 자식 쓰레드가 즉시 실행되어 done 변수를 1로 설정하고, 자고 있는 쓰레드를 깨우기 위해 시그널을 보내는 경우
    - 자식 쓰레드가 시그널을 보내지만 자고 있는 쓰레드가 없기 때문에 리턴한다.
    - 그 후, 부모 쓰레드가 실행되어 thr_join()을 호출하지만 done 변수가 1이기 때문에 wait 상태에 들어가지 않고 바로 리턴한다.

여기서 눈여겨 볼 점은 **부모 쓰레드가 조건(done 값)을 검사할 때 if문이 아니라 while문을 사용한다** 는 사실이다.

![img27](https://user-images.githubusercontent.com/35681772/59991492-90c11a80-9682-11e9-9e0b-a95d733ef274.png)

잘못된 구현의 예시다.

좌측은 done 변수를 사용하지 않는다. 이렇게 되면 부모쪽에서 while로 자식프로세스를 기다리는 wait() 에서 깨어나올 조건이 없게 된다. _sleep 상태로 들어가는 것, sleep 상태로부터 깨는것 그리고 락을 거는 것이 done이라는 상태 변수를 중심으로 구현이 된다._

우측은 락을 걸지 않아 경쟁 조건을 발생시킨다. 부모 쓰레드가 자식 쓰레드를 생성한 후, 부모 쓰레드가 계속 실행되어 done 변수가 0임을 확인하고 wait()을 호출하기 직전에 context switch가 일어나 자식 쓰레드로 전환된 경우, 자식은 done 변수를 1로 만들고 signal()을 보내지만 자고있는 쓰레드가 없다. 그리고 time slice를 소진하여 부모에게 CPU가 넘어왔을 때 곧장 wait()이 호출되며 sleep 상태로 들어간다. 문제는 이 부모 쓰레드를 깨울 수가 없다.

이를 통해 condition variable에 필요한 요소들을 확인하였다.

---

## 30.2 생산자 / 소비자(유한 버퍼) 문제 (The Producer/Consumer (Bounded Buffer) Problem)

동기화 문제로 아주 유명한 **생산자/소비자 (producer/consumer)** 문제가 있다. 이 문제는 유한 버퍼(bounded buffer) 문제로도 알려져 있다. Dijkstra는 이 문제를 통해 세마포어를 발명하게 되었다.

여러 개의 생산자 쓰레드와 소비자 쓰레드가 있고, 생산자는 데이터를 만들어 버퍼에 넣는 역할을, 소비자는 버퍼의 데이터를 꺼내어 사용하는 역할을 담당한다.

이러한 관계는 실제 시스템에서 쉽게 찾아볼 수 있는데, '멀티 쓰레드 웹 서버'의 경우 생산자는 HTTP 요청을 작업 큐(유한 버퍼)에 넣고, 소비자 쓰레드는 이 큐에서 요청을 꺼내서 처리하는 식으로 구현된다.

`grep foo file.txt | wc -l` 과 같은 파이프 명령으로 한 프로그램의 결과를 다른 프로그램에게 전달할 때도 유한 버퍼를 사용한다. 여기선 grep 프로세스가 생산자가 되고, wc 프로세스가 소비자가 된다. 이 둘 사이엔 커널 내부에 있는 유한 버퍼가 있다.

유한 버퍼는 '공유 자원' 이다. 따라서 경쟁 조건의 발생을 방지하기 위해 동기화가 필요하다.

![img28](https://user-images.githubusercontent.com/35681772/59991498-974f9200-9682-11e9-820e-186c8e8c833f.png)

위 코드를 보면, 생산자는 넣고 소비자는 꺼내어 쓸 수 있는 공유 버퍼(buffer)가 존재한다. 여기서 이 버퍼는 한 개의 정수형을 사용하여 하나의 값을 넣고 꺼낼 수 있는 구조이다.

put() 루틴은 버퍼가 비어있다고 보장이 되면(assert 문을 거쳐), 값을 버퍼에 넣은 후 count를 1로 설정하여 가득 찼음을 표시한다.

get() 루틴은 반대로 버퍼가 차 있는것이 보장이 되면(assert 문을 거쳐), 값을 꺼낸 후 버퍼가 비었다고 설정(count를 0으로)한뒤 읽은 값을 리턴한다.

<그림 30.5> 를 보면 생산자가 loop 횟수 만큼 공유 버퍼에 정수를 넣고, 소비자는 무한히 데이터를 공유 버퍼에서 꺼내고 있다.

---

### 불완전한 해답 (A Broken Solution)

put() 과 get() 루틴에 critical section이 존재하기 때문에 위 producer/consumer 패턴은 제대로 동작하지 않는다.

따라서 코드에 lock 과 condition variable 을 추가하여 mutual exclusion을 보장해야 한다.

![img30](https://user-images.githubusercontent.com/35681772/59991508-a0406380-9682-11e9-861d-a030cef37a5c.png)

<그림 30.6>에서 cond 컨디션 변수와 mutex 락을 선언하여 사용하였다. 하지만, if문을 사용하여 구현되어 있으므로, 하나 이상의 생산자/소비자 쓰레드가 존재하는 경우 제대로 동작하지 않는다.(반대로 하나의 생산자와 하나의 소비자만 존재하는 경우 제대로 동작한다.)

![img31](https://user-images.githubusercontent.com/35681772/59991512-a59dae00-9682-11e9-92be-3b38a89ab4d2.png)

멀티 쓰레드 구조에서 이 방법이 문제가 되는 이유는 위 그림을 통해 설명되어 있다.

하나의 소비자 쓰레드 C1이 먼저 실행되어 버퍼에 값이 없으므로 if문에서 wait()을 통해 sleep에 들어가게 되었고, 그 다음으로 생산자 쓰레드 P1이 실행되어 값을 생산하여 버퍼에 갱신하였다. 그리고 wait()을 통해 sleep에 들어가고, 또 다른 소비자 쓰레드 C2가 처음부터 실행되어 내려오다가 값이 차 있음을 확인하고 get()을 하여 값을 꺼냈다. 그 뒤 앞선 소비자 쓰레드 C1과 context switching 되었다면, 이 C1은 wait()에서 깨어나 락을 획득한 채 곧장 if문을 빠져나오면서 get()을 실행한다. 하지만 버퍼는 비어있게 되어 예외가 발생한다.

C2가 중간에 끼어들어 버퍼의 값을 소비하였기 때문에, C1이 비어 있는 버퍼를 읽는것을 막아주면 해결된다.

이렇게 'signal()은 쓰레드를 깨우기만 할 뿐, 깨어난 쓰레드가 실제 실행되는 시점에도 sleep 직전의 상태와 동일하다는 보장은 없다' 의 방식을 **Mesa semantic** 이라 한다. 이와 대비대는 개념은 **Hoarse semantic** 이고, 대부분의 시스템이 Mesa semantic 방식을 채용하고 있다.

---

### 개선된, 하지만 아직도 불완전한 : if문 대신 while문 (Better, But Still Broken: While, Not If)

이 문제는 if문을 while문으로 바꿔서 wait()에서 리턴된 시점에서 다시한번 루프를 돌아 조건을 확인하게 함으로써 해결할 수 있다. 즉, while문을 사용하면 깨어난 쓰레드는 곧장 공유 변수의 상태를 다시 확인하게 되는 것이다.

여기서 발생하는 또다른 문제점은, 임의의 소비자 또는 생산자 쓰레드가 signal()을 보내 다른 쓰레드를 깨울 때, 그 대상이 명확하지 않다는 것이다. 소비자 쓰레드 C1이 소비자 쓰레드 C2를 깨우는 상황이 발생할 수 있어 CPU의 낭비를 초래할 뿐 아니라, 최악의 경우 세 개의 쓰레드 모두 sleep하는 상황이 발생할 수 있다.

따라서 _signal()을 보낼 때, 그 대상을 명확하게 제시해야 한다._

---

### 단일 버퍼 생산자/소비자 해법 (The Single Buffer Producer/Consumer Solution)

signal()의 대상을 명시해주는 방법은 간단하게 해결이 된다. 두 개의 컨디션 변수를 사용하여 시스템의 상태가 변경되었을 때, 깨워야 하는 쓰레드에게만 시그널을 제대로 전달한다.

![img32](https://user-images.githubusercontent.com/35681772/59991519-ab938f00-9682-11e9-9965-63d8a4bfdbe3.png)

이렇게 두개의 condition variable을 사용하면, 생산자 쓰레드가 empty 변수에서 대기하고 fill에 대해서 signal()을 발생시킨다.

반대로 소비자 쓰레드는 fill 변수에서 대기하고, empty에 대해 signal()을 발생시킨다.

이렇게 하면 소비자가 다른 소비자를 깨우거나, 생산자가 다른 생산자를 깨우는 일은 발생하지 않게 된다.

---

### 제대로 동작하는 최종 생산자/소비자 해법 (The Correct Producer/Consumer Solution)

![img33](https://user-images.githubusercontent.com/35681772/59991527-b0f0d980-9682-11e9-84a2-16b8a7d82ac1.png)

따라서 위의 문제점을 개선시켜 제대로 동작하는 P/C pattern은 위와 같다.

버퍼 공간을 추가하여 대기 상태에 들어가기 전에 여러 값들이 생산될 수 있도록 하였고, 여러 개의 값이 대기 상태 전에 소비될 수 있도록 하였다.

생산자와 소비자의 경우 버퍼가 커지면 쓰레드 간 context switch 가 줄어들어 더 효율적으로 작동한다. 따라서 버퍼의 크기를 배열로 둬서 그 크기를 키우고, 버퍼 배열이 꽉 찼을때(p2) 생산자는 wait()을, 버퍼 배열이 empty일 때(c2) 소비자는 wait()을 하도록 설계하였다.

---

## 30.3 컨디션 변수 사용 시 주의점 : 포함 조건 (Covering Conditions)

condition variable을 사용하여 어떤 관심사의 쓰레드(생산자 or 소비자)를 깨울지는 구별이 가능하게 되었다.

![img3](https://user-images.githubusercontent.com/35681772/59991530-b817e780-9682-11e9-815f-83c20614f283.jpg)

하지만, 위의 예시를 보면 또 다른 문제점이 존재한다.

힙을 할당하고 해제하는 함수가 있고, 각 쓰레드 별 힙 할당시 필요로 하는 크기가 다르다고 가정하자.

힙에 빈 공간이 없는 상황에서 alloc 쓰레드 T1이 100 크기만큼의 힙 공간 할당을 요청하였고(A1(100)) 또 다른 alloc 쓰레드 T2가 10 만큼의 할당을 요청한 경우(A2(10)), 현재 빈 공간이 없으므로 두 쓰레드 모두 sleep 상태에 들어가게 된다.

그 후, free 쓰레드 F1이 꽉 차있는 힙에서 50의 공간을 free 하였다. 그 뒤 시그널을 보내는데 이 때, 잘못된 쓰레드를 깨울 수 있다.

만약 쓰레드 T1을 깨우게 된다면 T1은 100만큼의 할당을 요청하였으므로 free된 50만큼의 공간은 부족하다. 따라서 쓰레드 T2를 깨우는 것이 적절한 선택이 되지만, _어느 쓰레드를 깨워야 할 지 모르기 때문에 이 코드는 제대로 동작하지 않는다._

이것에 대한 해결책으로 pthread_cond_signal() 대신 **pthread_cond_broadcast()** 을 사용하면 된다.

pthread_cond_broadcast()는 대기 중인 모든 쓰레드를 다 깨운다. 그래서 깨어난 쓰레드들은 각자의 조건을 다시 확인하게 되고(while문 spin에 의해), 만약 자신의 조건에 부합하면 while문을 빠져나와 작업을 수행한다. 조건에 부합하지 않는다면(자기가 요구하는 힙 공간의 크기보다 free된 공간의 크기가 더 작은경우) 다시 sleep에 들어간다.

이 방법의 단점으로는 여러 쓰레드가 불필요하게 깨어날 수 있어 성능에 악영향을 미칠 수 있다는 것이다. 불필요하게 많은 쓰레드가 깨어나면 context switch 오버헤드가 커지게 된다.

이렇게 **같은 관심사 내의 어떤 쓰레드를 깨울지에 대한 이슈를 포함 조건(covering conditions)** 라 하고, 위의 메모리 할당 문제의 경우 broadcast()를 사용하는것이 자명한 해법으로 알려져 있다.

---

## 30.4 요약 (Summary)

락과 함께 주요 동기화 수단인 condition variable에 대해 알아보았다. 컨디션 변수는 프로그램 상태가 기대한 것과 다를 경우 쓰레드가 대기하도록 하여 주요 동기화 문제 몇 가지를 해결해준다.

---