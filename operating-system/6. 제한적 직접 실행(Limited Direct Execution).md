
# 6. 제한적 직접 실행(Limited Direct Execution)

CPU를 가상화하기 위해서 운영체제는 여러 작업들이 동시에 실행되는 것처럼 보이도록 물리적인 CPU를 공유한다. 즉, 한 프로세스를 잠시 실행, 다른 프로세스를 잠시 실행, 이런 식으로 계속해서 잠깐씩 실행시키며 **CPU 시간을 나누어 씀으로써 가상화를 구현한다.** 

그러나 이러한 가상화 기법을 해결하는데엔 다음과 같은 제한사항이 존재한다
  - 성능 저하 : 시스템에 과도한 오버헤드를 주지 않으면서 가상화를 구현해야함. OS가 개입하는 것 자체가 오버헤드를 일으키는 것이 된다. 따라서 퍼포먼스의 저하를 초래한다는 것.
  - 제어 문제 : CPU에 대한 통제를 유지하면서 프로세스를 효율적으로 실행시켜야함.

제어권을 유지하면서 성능 저하가 없도록 하는 것이 이번 장에서의 관전 포인트가 된다.

---

## 6.1 기본 원리 : 제한적 직접 실행(Limited Direct Execution)

*제한된 직접 실행(Limited Directed Execution)* 은 프로그램을 '제한적으로' CPU 상에서 직접 실행시키는 것이다. 

![img5](https://user-images.githubusercontent.com/35681772/59988584-86008880-9676-11e9-9b43-7770c668e017.png)

별다른 제한이 없는 직접 실행 프로토콜이다. 그러나 이러한 직접 접근은 CPU를 가상화함에 있어 *"프로그램이 운영체제가 원하지 않는 작업을 하게 되는 경우 어떻게 할 것인가?"* 의 문제점을 내포한다. 또한, 가상화를 위해 CPU를 공유하며 사용해야 하는데 프로세스가 직접 실행을 통해 별다른 제약 없이 실행된다면 중간에 프로그램의 실행을 중단하고 다른 프로세스로 전환이 불가능하다. **따라서 이런 문제점은 운영체제가 제어권(Control)을 갖게 됨으로써 해결할 수 있다.**

---

## 6.2 문제점 1 : 제한된 연산(Restricted Operations)

직접 실행의 장점은 프로그램이 하드웨어 CPU에서 실행되기 때문에 빠르다는 것이다. 그러나 CPU에서 직접 실행시키는 경우 프로세스가 특수한 요청(I/O 요청 또는 CPU나 메모리 같은 시스템 리소스에 대한 추가 할당 요청 등)을 하게된다면 어떻게 해야할까?

만약 프로세스가 원하는 대로 모든 것을 할 수 있게 방치한다면, 프로세스는 전체 디스크를 읽고 쓸 수 있어 보안 이슈가 발생하게 된다.

따라서 **사용자 모드(user mode)** 와 **커널 모드(kernel mode)** 라는 차별적 권한을 도입하여 할 수 있는 일을 제한하게 되었다. 이로써 OS는 control을 유지한 채 performance를 올릴 수 있게 된다.

  - **사용자 모드(user mode)** : 사용자 모드에서는 할 수 있는 일이 제한된다. 예를 들어 I/O 요청을 하면 프로세서가 예외를 발생시켜 운영체제는 해당 프로세스를 제거한다.
  - **커널 모드(kernel mode)** : 특수한 명령어를 포함하여 원하는 모든 작업을 수행할 수 있다. 운영체제의 중요한 코드들이 실행된다.

사용자 모드(user mode) 프로세스가 디스크 읽기와 같은 특수 명령어를 실행해야 하는 경우 해당 프로세스에게 **시스템 콜(system call)** 을 제공하여 커널의 주요 기능을 잠시 제공하게 된다.

**시스템 콜(system call)** : OS에게 '~좀 해줘' 와 같이 요청하는것이다. 여기엔 주로 리소스 할당이나 사용등이 포함된다. OS가 통제중이기 때문에 허락을 받고 써야하는데 허락을 받기위해 요청하는것이다.

시스템 콜을 실행하기 위해 프로그램은 *trap(특수 명령어)* 을 실행하게 되고, trap은 커널 안으로 들어감과 동시에 특권 수준을 커널 모드로 상향 조정한다. 커널 모드에서 운영체제는 모든 명령어를 실행할 수 있어 프로세스가 요청한 작업을 처리할 수 있게 된다.

완료되면 운영체제는 *return-from-trap(특수 명령어)* 를 호출하여 특권 수준을 사용자 모드로 다시 하향 조정한다.

하드웨어는 trap 명령어를 수행할 때 호출한 프로세스의 필요한 레지스터들을 저장해서 return시 해당 프로세스로 정확하게 리턴하게 된다. 이렇게 return에 필요한 Program Counter, flag 및 레지스터 값들을 각 프로세스의 **커널 스택(kernel stack)** 에 저장하여 return시 스택에서 pop하여 사용자 모드 프로그램의 실행을 재개하는 식이다.

trap은 트랩 테이블(trap table)을 참조하여 운영체제 코드의 어떤 부분을 실행할지 결정하게 된다. 커널은 부팅시 이 트랩 테이블을 만들고 이를 이용하여 시스템을 통제하게 된다. 

컴퓨터가 부트될 때는 커널 모드에서 동작하기 때문에 이 때 운영체제는 하드웨어에게 예외 사건이 일어났을 때 어떤 코드를 실행해야 할지의 정보를 가지고 있는 **트랩 핸들러(trap handler)** 의 위치를 알려주게 된다.

![img7](https://user-images.githubusercontent.com/35681772/59988592-8e58c380-9676-11e9-9908-e67d0311fc71.png)

LDE 프로토콜은 위와같이 프로세스 실행 전, 프로세스를 실행할 때 두 단계로 진행된다.

  - 프로세스 실행 전 : 커널은 트랩 테이블을 초기화하고, CPU는 그 트랩 테이블을 나중에 사용하기 위하여 테이블의 위치를 기억한다.
  - 프로세스 실행할 때 : 사용자 프로세스를 실행 전, 커널 모드에서 프로세스를 위한 노드 할당 및 메모리 할당 등의 작업을 수행하고 *return-from-trap* 을 거쳐 CPU를 사용자 모드로 전환하고 프로세스 실행을 시작한다. 프로세스가 시스템 콜을 호출하면 운영체제로 다시 trap되어 그 trap을 처리하고 다시 return되는 식이다.

---

## 6.3 문제점 2 : 프로세스 간 전환

운영체제는 실행 중인 프로세스를 계속 실행할 것인지, 멈추고 다른 프로세스를 실행할 것인지를 결정하여 프로세스간 전환을 할 수 있어야 한다. 그러나 *CPU에서 프로세스가 실행 중이라는 것은 운영체제는 실행중이지 않다는 것을 의미하므로* **운영체제는 어떻게 CPU를 다시 획득하여 프로세스를 전환할 것인가** 에 대한 이슈가 제기된다.

---

### 협조 방식 : 시스템 콜 기다리기

협조(cooperative) 방식은 운영체제가 프로세스들이 합리적으로 행동할 것이라 신뢰하고, 프로세스는 자주 시스템 콜을 호출하여 CPU의 제어권을 운영체제에게 넘겨주는 방식을 지칭한다. 이 방식에서 운영체제는 yield 시스템 콜을 제공하여 프로세스가 운영체제에게 제어권을 넘겨 다른 프로세스를 실행할 수 있게 한다.

응용 프로그램이 비정상적인 행위(어떤 수를 0으로 나누기, 접근할 수 없는 메모리에 접근 시도 등)를 하면 운영체제로의 트랩이 일어나고 그러면 운영체제는 다시 CPU를 획득하여 해당 프로세스를 kill한다.

그러나 이런 협조 방식에서는 악의적 프로세스에 대응이 불가능하다.

---

### 비협조 방식 : 운영체제가 전권을 행사(The OS Takes Control)

프로세스가 운영체제에게 제어권을 넘기지 않는 경우, 운영체제는 하드웨어의 추가적인 도움 없이는 할 수 있는 일이 거의 없다. 따라서 프로세스가 비협조적인 상황에서도 CPU의 제어권을 뺏어오기 위해선 **타이머 인터럽트(timer interrupt)** 를 이용하는 방법이 있다.

타이머 인터럽트는 짧은 시간마다 인터럽트를 발생시켜 현재 프로세스를 중단시키고 운영체제의 *인터럽트 핸들러(interrupt handler)* 를 실행시켜 운영체제가 CPU 제어권을 다시 얻게끔 한다.

이렇게 하기위해 운영체제는 부팅될 때 하드웨어에게 timer interrupt 발생시 실행할 코드를 알려준다. 

interrupt 발생시 하드웨어는 실행중이던 프로그램의 상태를 저장하여 나중에 있을 return-from-trap 명령어가 중지된 프로그램을 다시 재개하도록 해야 한다.

---

### 문맥의 저장과 복원(Saving and Restoring Context)

Context Switching이란 한 프로세스의 중단 시점의 작업내역을 Kernel Stack에 저장하여 다른 프로세스로 전환하고 또, 하던일들을 이어서 다시 할수 있게 해주는 솔루션을 말한다.

![context](https://user-images.githubusercontent.com/35681772/59988602-99abef00-9676-11e9-9bbf-ac9ed79a871f.jpg)

운영체제가 제어권을 다시 획득하면 *현재 실행중인 프로세스를 계속 실행할 것인지 아니면 다른 프로세스로 전환할 것인지* 를 결정해야 한다. 이는 **스케줄러(scheduler)** 가 담당한다.

다른 프로세스로 전환하기로 결정이 되면, 운영체제는 **문맥 교환(context switch)** 라는 코드를 실행시킨다. *Context switch는 현재 실행 중인 프로세스의 레지스터 값을 커널 스택 같은곳에 저장하고 곧 실행될 프로세스의 커널 스택으로부터 레지스터 값을 복원하는 것이다.* Context Switch가 일어나면 운영체제는 *'return-from-trap' 명령어가 마지막으로 실행될 때 현재 프로세스가 아닌 다른 프로세스로 리턴하여 실행을 다시 시작하게 된다.*

프로세스 전환을 위하여 운영체제는 어셈블리 코드를 사용하여 *현재 실행중인 프로세스의 레지스터, PC뿐 아니라 현재 커널 스택 포인터를 저장* 한다. 그리고 *실행하려는 다른 프로세스의 이 값들을 복원하고 커널 스택을 이 프로세스의 커널 스택으로 전환* 한다. 그리고 'return-from'trap' 명령어를 실행함으로써 다른 프로세스로의 전환이 완료된다.

![assem](https://user-images.githubusercontent.com/35681772/59988608-a0d2fd00-9676-11e9-9f8d-44467f1f2a57.jpg)

OS의 대부분이 C code로 작성되어 있는데, Context Switch는 assembly로 작성되어 있다. 레지스터 등의 리소스를 직접 제어함으로써 퍼포먼스를 중요시 여기기 위함이다.

---

## 6.4 병행성(Concurrency) 이슈

시스템 콜을 처리하는 도중 타이머 인터럽트가 발생하거나, 하나의 인터럽트를 처리하고 있는 도중 다른 인터럽트가 또 발생한다면?

이런 이슈들을 *'병행성(Concurrency)'* 이라 하고 나중에 다루게 된다. 간단하게 인터럽트를 처리하는 동안은 다른 인터럽트는 불능화 시킴으로써 해결이 가능하다.

또한 **락(lock)** 을 통해 내부 자료구조에 동시에 접근하는것을 방지하여 이런 부분을 개선하는 구조이다.

---

## 6.5 요약

CPU 가상화를 구현하기 위한 핵심적인 저수준 기법들에 대해 다뤄봤고 이를 **제한적 직접 실행** 이라고 부른다. 간단하게 CPU에서 실행하고 싶은 프로그램을 실행시키되, 운영체제가 CPU를 사용하지 못하는 상황이라도 해당 프로세스의 작업을 제한할 수 있도록 하드웨어를 셋업하는것이다.

그렇다면 *어떤 시점에 어떤 프로세스를 실행시켜야 할지* 에 대한 이슈가 남았는데, 이를 *스케줄러* 가 담당하고 있어 다음에 다루게 된다. 스케줄러는 프로세스들의 ready, block 상태를 결정해 준다.

---
