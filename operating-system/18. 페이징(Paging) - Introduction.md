# 18\. 페이징(Paging) : Introduction

운영체제는 공간 관리에 다음 두가지 기법을 사용한다. 

1) 세그멘테이션(segmentation) : 가변 크기의 조각들로 분할. 태생적으로 공간을 다양한 크기의 청크로 분할하므로 **단편화(fragmentation)** 문제가 발생. 

2) **페이징(paging)** : 공간을 동일한 고정 크기의 조각으로 분할한다. 각각의 고정 크기 단위를 **페이지(page)** 라 부르고, 물리 메모리도 고정 크기의 슬롯인 **페이지 프레임(page frame)** 으로 간주한다. _페이지를 사용하여 어떻게 메모리를 가상화할 수 있을지_ 에 대해 알아본다.

Segmentation 에서의 외부 단편화 이슈를 개선하기 위해 paging이 도입되었다.

근데 Paging Table에는 

- 용량이 너무 크다
- 속도가 너무 느리다

이런 이슈가 있어 이걸 개선하기 위한 방법들을 순차적으로 배운다.

![1](https://user-images.githubusercontent.com/35681772/59990269-691b8380-967d-11e9-8540-7858c3e1b840.jpg)

---

## 18.1 간단한 예제 및 개요

![6_1](https://user-images.githubusercontent.com/35681772/59990283-70429180-967d-11e9-97f8-95bb178c05a2.png)

- 총 크기가 64바이트 이면서 4개의 16바이트 페이지로 구성된 작은 주소공간
- 페이지는 **고정크기의 슬롯들로 구성된 물리 메모리**
- 가상페이지(VP)0 → 물리프레임(PF)3, 가상페이지(VP)1 → 물리프레임(PF)7 과 같이 대응됨. VP = Virtual Page, PF = Physical Frame.

프로세스가 주소 공간을 바라볼 땐 좌측처럼 linear하게 존재하는것 처럼 인지하게 된다.

---

### 페이징의 장점

1) _유연성(flexibility)_ : 효율적으로 주소 공간 개념을 지원. 예를 들어, 힙과 스택이 어느 방향으로 커지는지, 어떻게 사용되는지에 대한 가정이 필요없음. 페이지 단위로 할당해 주기 때문에 growth direction 고려할 필요 없다.

2) _빈 공간 관리의 단순함(simplicity of free-space management)_ : 64바이트의 주소공간을 위의 그림처럼 8페이지의 물리 메모리에 탑재하는 경우 _페이지 단위의 빈 공간 리스트_ 중에서 첫 네 개 페이지를 선택하면 된다. Free space의 크기가 page 단위로 균일하기 때문에 앞서 다뤘던 fit한 space를 할당해주기 위한 작업이 필요가 없어진다. Free page list에서 특정 개수만큼 할당만 해주면 된다.

단, Paging을 하면 Fragmentation이 아예 없는가? 그건 아니다. Internal Fragmentation 이슈는 존재한다.

---

### 페이지 테이블(page table)

주소 공간의 각 가상 페이지에 대한 물리 메모리 위치를 기록하기 위하여 운영체제가 **프로세스마다 유지하는 자료 구조**. 주소 공간상의 가상 페이지 주소 변환(address translation) 정보를 저장한다.

**페이지 테이블은 프로세스마다 존재** 하기 때문에 다른 프로세스를 실행해야 한다면 운영체제는 이 프로세스를 위한 다른 페이지 테이블이 필요하다.

### 프로세스가 생성한 가상 주소의 변환

![img3](https://user-images.githubusercontent.com/35681772/59990294-7afd2680-967d-11e9-997d-fa5aa45ecece.png)

가상 페이지 번호(Virtual Page Number, VPN)와 페이지 내의 Offset 2개의 구성요소로 분할한다.

가상 주소공간의 크기가 64바이트이므로 가상 주소는 6비트가 필요하고(2^6 = 64), 각 페이지의 하나당 크기가 16바이트이기 때문에 전체 물리 메모리에서 4개의 물리프레임(PF)를 필요로 한다(64 / 16 = 4).

__가상 페이지 번호(VPN)__ : 상위 2비트가 4개의 페이지에 각각에 해당하는 가상 페이지 번호(VPN)을 나타내게 된다.

__Offset__ : 그 외 나머지 비트는 페이지 내에서 우리가 원하는 바이트의 위치정보를 담고 있다.

위 예제에서 프로세스가 가상 주소 21을 생성한 것을 예시로 들고있다(십진수 21은 이진수 010101). 

따라서 가상주소 21은 가상 페이지 01의 5번째(이진수 0101) 바이트에 대응된다.

21이라는 숫자는 '주소'다. 근데 Virtual Address라는 것. 따라서 우리가 알고싶은 것은 실제 physical memory상 어디에 위치하고 있는지가 궁금하다. 이걸 Address Translation이라 하고 이 정보를 Page table이 가지고 있다는 것.

![img5](https://user-images.githubusercontent.com/35681772/59990299-818b9e00-967d-11e9-9bc9-2588c8dc2237.png)

이 가상 번호를 가지고 물리 프레임 번호(Physical Frame Number, PFN) 혹은 물리 페이지 번호(Physical Page Number, PPN)로 교체시 페이지 테이블에서 PFN은 7(이진수 111, 그림 18.2에서 VPN 01 = 페이지 1 = PFN 7)이므로 위와같은 변환을 거치게 되어 물리 주소 1110101을 얻어내게 된다.

Virtual page의 number 즉, VPN은 굳이 저장이 필요하지 않다. 어짜피 VPN은 linear하기 때문에 이걸 index로 대체하고 그 index의 Element로 Physical Frame Number만 가지고 있으면 되기 때문.

_여기서 주목할 점은 Offset값은 변하지 않는다는 것_ 이다.

---

## 18.2 페이지 테이블은 어디에 저장되는가

![img6](https://user-images.githubusercontent.com/35681772/59990311-8a7c6f80-967d-11e9-82e3-5fa90157c72c.png)

페이지 테이블의 경우 _페이지 테이블 엔트리(Page Table Entry, PTE)_ 마다 4바이트가 필요하다고 가정할 경우, 20비트 VPN이 존재한다면 4 * 2^20 = 4MB의 메모리가 필요하게 되고, 이러한 프로세스가 100개 실행 중인 경우 400MB의 메모리를 필요로 한다. 즉, 페이지 테이블은 매우 커질 수 있기 때문에 *각 프로세스의 페이지 테이블은 메모리에 저장* 한다(MMU가 아니라).

Segmentation 에서의 Segment는 많아야 10개 보통 3~4개였다. 근데 페이지의 개수는 2^20처럼 너무 많아 발생하는 크기의 issue 때문에 페이지 테이블은 memory에 저장된다.

---

## 18.3 페이지 테이블에는 실제 무엇이 있는가

페이지 테이블은 가상 주소(가상 페이지 번호, VPN)를 물리 주소(물리 프레임 번호, PFN)로 매핑(mapping)하는데 사용되는 자료구조이다. 가장 간단한 형태는 선형 페이지 테이블(Linear Page Table)로 단순한 배열이다. 운영체제는 원하는 PFN을 찾기 위하여 VPN으로 배열의 엔트리에 접근하고 그 항목의 페이지 테이블 엔트리 (PTE)를 검색한다.

linear page table : Virtual address 상에서 페이지 테이블은 virtual address 상에서의 페이지 순서(즉, linear)를 그대로 가지고 가게 된다. 그래서 linear page table이 되는 것.

따라서 linear하다? 배열의 경우 사용을 하지 않아도 특정 공간만큼 선언시 그 크기를 차지하게 된다. 그렇기 때문에 페이지는 수십억개인데 만약 해당 프로세스에서 하나의 페이지만 쓰는 경우 'memory waste' 발생.

### 페이지 테이블 엔트리(Page Table Entry, PTE)의 비트들

![img7](https://user-images.githubusercontent.com/35681772/59990313-90725080-967d-11e9-8eaa-3e538143247b.png)

이 PTE들의 array가 page table이 된다.

- _Valid bit_ : 특정 변환이 유효한지를 나타내는 비트. 예를 들어, 주소공간 상에서 스택과 힙 사이의 미사용 공간의 경우 무효(invalid)로 표시하고, 프로세스가 그 공간에 접근하려 하면 운영체제에 트랩을 발생시켜 알려준다. **주소공간의 미사용 페이지를 모두 표시함으로써 이 미사용 페이지에 물리 프레임을 할당할 필요를 없애 대량의 메모리를 절약한다.**

- _Protection bit_ : 페이지의 Read fron(읽을 수 있는지), Written to(쓸 수 있는지), Executed from(실행될 수 있는지) 상태를 나타내는 비트. Protection bit이 허용하지 않는 방식으로 페이지에 접근시 트랩을 발생시킨다.

- _Present bit_ : 해당 페이지가 물리 메모리에 있는지 디스크에 있는지(스왑 아웃 되었는지, Swappped out)를 나타낸다. _스와핑은 운영체제가 드물게 사용되는 페이지를 디스크로 이동시켜 물리 메모리를 비울 수 있게 하는것을 말한다._

- _Dirty bit_ : 메모리에 반입된 후 페이지가 변경되었는지 여부를 나타내는 비트.

- _Reference bit(Accessed bit)_ : 페이지가 참조되었는지를 나타내기위한 비트. 페이지의 참조 빈도는 해당 페이지가 메모리에 유지되어야 할지 그렇지 않을지를 결정하는데 유용하여 _페이지 교체_ 에 매우 중요하다.

---

## 18.4 페이징 : 너무 느림

![img8](https://user-images.githubusercontent.com/35681772/59990322-9cf6a900-967d-11e9-9b3d-42d617c0be31.png)

- 페이징을 사용하여 위와같은 한번의 메모리 참조에 필요한 연산은 아래와 같다.

![img8](https://user-images.githubusercontent.com/35681772/59990327-a253f380-967d-11e9-9dfc-c91a639f94d4.jpg)

여기서 확인할 수 있듯, Page Table은 VPN을 PFN으로 바꿔줄 정보를 가지고 있을 뿐이다. Offset은 Virtual Address에 이미 있다.

- 가상주소를 물리주소로 변환 → 프로세스의 페이지 테이블에서 적절한 항목(엔트리)를 가져와서 변환 → 물리 메모리에 탑재 하는 과정을 보여준다. 여기선 페이지 테이블 베이스 레지스터(PTBR)가 페이지 테이블의 시작 주소(물리 주소)를 저장한다고 가정하였다.
- 가상 주소 21(이진수 010101)에 대해 VPN_MASK는 0x30(이진수 110000)으로 설정되어 전체 가상 주소에서 AND연산으로 VPN 비트만 골라낸다(이진수 010000). 그 다음 Offset 비트 수에 따라 SHIFT 연산을 하여(RSHIFT 4) VPN 값을 얻어낸다(이진수 01). 이 값을 PTBR이 가리키는 PTE 배열에 대한 인덱스로 사용하여 물리 주소에 접근하는 것이다.
- 이 물리 주소를 통해 하드웨어는 메모리에서 PTE를 반입하고 PFN을 추출한 뒤 SHIFT 연산을 하여(LSHIFT 4) 가상 주소의 Offset과 OR연산으로 최종 주소를 형성한다.
- 최종적으로 위와같은 절차를 거치게 되는데, 모든 메모리 참조에 대해 먼저 페이지 테이블에서 변환 정보를 반입해야 하기 때문에 반드시 최소 한 번의 메모리 참조가 필요하다.
- **메모리 참조는 비용이 비싸고 프로세스는 2배 이상 느려지게 된다.**
- 따라서 페이징 기술은 페이지 테이블로 인해 시스템이 메우 느려질 수 있으며 매우 많은 메모리를 차지하는 결과를 초래할 수 있다.

![2](https://user-images.githubusercontent.com/35681772/59990333-aa139800-967d-11e9-9927-65d53b07ec5b.jpg)

---

## 18.5 메모리 트레이스 : 컴퓨터가 실행하는 절차


![img9](https://user-images.githubusercontent.com/35681772/59990342-b1d33c80-967d-11e9-9a35-0d98c8516c6e.png)

- 배열에 값을 담는 C언어로 작성된 코드에서, 어셈블리어로 변환한 다음 실제 메모리에 접근하는 과정은 위와 같다.
- 여기서 고려해야 할 몇가지 페이지들이 존재한다. 1) 코드가 상주하는 가상 페이지, 2) 배열 자체
- 루프당 10번의 메모리 접근이 존재하게 된다. 네번의 명령어 반입, 한번의 메모리 갱신, 그리고 이 다섯번의 연산을 위한 주소 변환에 소요되는 다섯번의 페이지 테이블 접근 총 10번의 접근을 필요로 한다.

![3](https://user-images.githubusercontent.com/35681772/59990349-bac40e00-967d-11e9-84da-4b62251ed65e.jpg)

---

## 18.6 요약

메모리 가상화에 대한 해결책으로 페이징 기법을 알아보았다. 페이징 기법은 다음과 같은 장점이 있다.

- _외부 단편화를 초래하지 않는다_ : 메모리를 고정 크기의 단위로 나누기 때문에 외부 단편화를 초래하지 않는다(It does not lead to external fragmentation, as paging (by design) divides memory into fixed-sized units).
- _유연성(Flexible)_ : 가상 주소 공간의 드문 사용을 허용하기 때문에 유연성이 좋다(enabling the sparse use of virtual address spaces).

그러나 다음과 같은 단점이 있다.

- _Slower Machine_ : 제대로 구현하지 않으면 페이지 테이블 접근을 위한 많은 추가적 연산을 필요로 하여 컴퓨터가 매우 느려진다 → TLB를 통해 개선
- _Memory Waste_ : 어플리케이션 데이터 대신 페이지 테이블로 가득 차 메모리 낭비를 초래한다 → advanced page table에서 Hierarchy 하게 page table을 구성해서 개선

---